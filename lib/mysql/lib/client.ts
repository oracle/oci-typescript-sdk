/**
 * MySQL Database Service API
 * The API for the MySQL Database Service
 * OpenAPI spec version: 20190415
 * Contact: mysql-cloud-dev_ww_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { ChannelsWaiter } from "./channels-waiter";
import { DbBackupsWaiter } from "./dbbackups-waiter";
import { DbSystemWaiter } from "./dbsystem-waiter";
import { MysqlaasWaiter } from "./mysqlaas-waiter";
import { ReplicasWaiter } from "./replicas-waiter";
import { WorkRequestsWaiter } from "./workrequests-waiter";
import {
  composeResponse,
  composeRequest,
  GenericRetrier,
  developerToolConfiguration
} from "oci-common";
const Breaker = require("opossum");

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum ChannelsApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class ChannelsClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ChannelsWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "Channels";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`ChannelsClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        ChannelsClient.serviceEndpointTemplate,
        this._region,
        ChannelsClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        ChannelsClient.serviceEndpointTemplate,
        this._regionId,
        ChannelsClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ChannelsClient.serviceEndpointTemplate,
      region,
      ChannelsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ChannelsClient.serviceEndpointTemplate,
      regionId,
      ChannelsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new ChannelsWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): ChannelsWaiter {
    this._waiters = new ChannelsWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ChannelsWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Creates a Channel to establish replication from a source to a target.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateChannelRequest
   * @return CreateChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CreateChannel.ts.html |here} to see how to use CreateChannel API.
   */
  public async createChannel(
    createChannelRequest: requests.CreateChannelRequest
  ): Promise<responses.CreateChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#createChannel.");
    const operationName = "createChannel";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createChannelRequest.opcRequestId,
      "opc-retry-token": createChannelRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createChannelRequest.createChannelDetails,
        "CreateChannelDetails",
        model.CreateChannelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateChannelResponse>{},
        body: await response.json(),
        bodyKey: "channel",
        bodyModel: model.Channel,
        type: "model.Channel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified Channel.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteChannelRequest
   * @return DeleteChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteChannel.ts.html |here} to see how to use DeleteChannel API.
   */
  public async deleteChannel(
    deleteChannelRequest: requests.DeleteChannelRequest
  ): Promise<responses.DeleteChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#deleteChannel.");
    const operationName = "deleteChannel";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Channel/DeleteChannel";
    const pathParams = {
      "{channelId}": deleteChannelRequest.channelId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteChannelRequest.ifMatch,
      "opc-request-id": deleteChannelRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels/{channelId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteChannelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the full details of the specified Channel, including the user-specified
   * configuration parameters (passwords are omitted), as well as information about
   * the state of the Channel, its sources and targets.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetChannelRequest
   * @return GetChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetChannel.ts.html |here} to see how to use GetChannel API.
   */
  public async getChannel(
    getChannelRequest: requests.GetChannelRequest
  ): Promise<responses.GetChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#getChannel.");
    const operationName = "getChannel";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Channel/GetChannel";
    const pathParams = {
      "{channelId}": getChannelRequest.channelId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getChannelRequest.opcRequestId,
      "if-none-match": getChannelRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels/{channelId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetChannelResponse>{},
        body: await response.json(),
        bodyKey: "channel",
        bodyModel: model.Channel,
        type: "model.Channel",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists all the Channels that match the specified filters.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListChannelsRequest
   * @return ListChannelsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListChannels.ts.html |here} to see how to use ListChannels API.
   */
  public async listChannels(
    listChannelsRequest: requests.ListChannelsRequest
  ): Promise<responses.ListChannelsResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#listChannels.");
    const operationName = "listChannels";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/ChannelSummary/ListChannels";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listChannelsRequest.compartmentId,
      "dbSystemId": listChannelsRequest.dbSystemId,
      "channelId": listChannelsRequest.channelId,
      "displayName": listChannelsRequest.displayName,
      "lifecycleState": listChannelsRequest.lifecycleState,
      "isEnabled": listChannelsRequest.isEnabled,
      "sortBy": listChannelsRequest.sortBy,
      "sortOrder": listChannelsRequest.sortOrder,
      "limit": listChannelsRequest.limit,
      "page": listChannelsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listChannelsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listChannelsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListChannelsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.ChannelSummary,
        type: "Array<model.ChannelSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listChannelsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.ChannelSummary objects
   * contained in responses from the listChannels operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllChannels(
    request: requests.ListChannelsRequest
  ): AsyncIterableIterator<model.ChannelSummary> {
    return paginateRecords(request, req => this.listChannels(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listChannelsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listChannels operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllChannelsResponses(
    request: requests.ListChannelsRequest
  ): AsyncIterableIterator<responses.ListChannelsResponse> {
    return paginateResponses(request, req => this.listChannels(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.ChannelSummary objects
   * contained in responses from the listChannels operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listChannelsRecordIterator(
    request: requests.ListChannelsRequest
  ): AsyncIterableIterator<model.ChannelSummary> {
    return paginateRecords(request, req => this.listChannels(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listChannels operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listChannelsResponseIterator(
    request: requests.ListChannelsRequest
  ): AsyncIterableIterator<responses.ListChannelsResponse> {
    return paginateResponses(request, req => this.listChannels(req));
  }

  /**
   * Resets the specified Channel by purging its cached information, leaving the Channel
   * as if it had just been created. This operation is only accepted in Inactive Channels.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ResetChannelRequest
   * @return ResetChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ResetChannel.ts.html |here} to see how to use ResetChannel API.
   */
  public async resetChannel(
    resetChannelRequest: requests.ResetChannelRequest
  ): Promise<responses.ResetChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#resetChannel.");
    const operationName = "resetChannel";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Channel/ResetChannel";
    const pathParams = {
      "{channelId}": resetChannelRequest.channelId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": resetChannelRequest.ifMatch,
      "opc-request-id": resetChannelRequest.opcRequestId,
      "opc-retry-token": resetChannelRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      resetChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels/{channelId}/actions/reset",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ResetChannelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Resumes an enabled Channel that has become Inactive due to an error. The resume operation
   * requires that the error that cause the Channel to become Inactive has already been fixed,
   * otherwise the operation may fail.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ResumeChannelRequest
   * @return ResumeChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ResumeChannel.ts.html |here} to see how to use ResumeChannel API.
   */
  public async resumeChannel(
    resumeChannelRequest: requests.ResumeChannelRequest
  ): Promise<responses.ResumeChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#resumeChannel.");
    const operationName = "resumeChannel";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Channel/ResumeChannel";
    const pathParams = {
      "{channelId}": resumeChannelRequest.channelId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": resumeChannelRequest.ifMatch,
      "opc-request-id": resumeChannelRequest.opcRequestId,
      "opc-retry-token": resumeChannelRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      resumeChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels/{channelId}/actions/resume",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ResumeChannelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the properties of the specified Channel.
   * If the Channel is Active the Update operation will asynchronously apply the new configuration
   * parameters to the Channel and the Channel may become temporarily unavailable. Otherwise, the
   * new configuration will be applied the next time the Channel becomes Active.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateChannelRequest
   * @return UpdateChannelResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateChannel.ts.html |here} to see how to use UpdateChannel API.
   */
  public async updateChannel(
    updateChannelRequest: requests.UpdateChannelRequest
  ): Promise<responses.UpdateChannelResponse> {
    if (this.logger) this.logger.debug("Calling operation ChannelsClient#updateChannel.");
    const operationName = "updateChannel";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Channel/UpdateChannel";
    const pathParams = {
      "{channelId}": updateChannelRequest.channelId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateChannelRequest.ifMatch,
      "opc-request-id": updateChannelRequest.opcRequestId,
      "opc-retry-token": updateChannelRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateChannelRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/channels/{channelId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateChannelRequest.updateChannelDetails,
        "UpdateChannelDetails",
        model.UpdateChannelDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateChannelResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum DbBackupsApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class DbBackupsClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DbBackupsWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "DbBackups";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`DbBackupsClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        DbBackupsClient.serviceEndpointTemplate,
        this._region,
        DbBackupsClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        DbBackupsClient.serviceEndpointTemplate,
        this._regionId,
        DbBackupsClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DbBackupsClient.serviceEndpointTemplate,
      region,
      DbBackupsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DbBackupsClient.serviceEndpointTemplate,
      regionId,
      DbBackupsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new DbBackupsWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DbBackupsWaiter {
    this._waiters = new DbBackupsWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DbBackupsWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Cancels the scheduled deletion of a backup and moves it to ACTIVE state.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CancelBackupDeletionRequest
   * @return CancelBackupDeletionResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CancelBackupDeletion.ts.html |here} to see how to use CancelBackupDeletion API.
   */
  public async cancelBackupDeletion(
    cancelBackupDeletionRequest: requests.CancelBackupDeletionRequest
  ): Promise<responses.CancelBackupDeletionResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#cancelBackupDeletion.");
    const operationName = "cancelBackupDeletion";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/CancelBackupDeletion";
    const pathParams = {
      "{backupId}": cancelBackupDeletionRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": cancelBackupDeletionRequest.ifMatch,
      "opc-request-id": cancelBackupDeletionRequest.opcRequestId,
      "opc-retry-token": cancelBackupDeletionRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      cancelBackupDeletionRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}/actions/cancelDeletion",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CancelBackupDeletionResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a DB System Backup into a different compartment.
   * When provided, If-Match is checked against ETag values of the Backup.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ChangeBackupCompartmentRequest
   * @return ChangeBackupCompartmentResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ChangeBackupCompartment.ts.html |here} to see how to use ChangeBackupCompartment API.
   */
  public async changeBackupCompartment(
    changeBackupCompartmentRequest: requests.ChangeBackupCompartmentRequest
  ): Promise<responses.ChangeBackupCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DbBackupsClient#changeBackupCompartment.");
    const operationName = "changeBackupCompartment";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/ChangeBackupCompartment";
    const pathParams = {
      "{backupId}": changeBackupCompartmentRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": changeBackupCompartmentRequest.ifMatch,
      "opc-request-id": changeBackupCompartmentRequest.opcRequestId,
      "opc-retry-token": changeBackupCompartmentRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      changeBackupCompartmentRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeBackupCompartmentRequest.changeBackupCompartmentDetails,
        "ChangeBackupCompartmentDetails",
        model.ChangeBackupCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeBackupCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a copy of a DB system backup available in the specified source region.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CopyBackupRequest
   * @return CopyBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CopyBackup.ts.html |here} to see how to use CopyBackup API.
   */
  public async copyBackup(
    copyBackupRequest: requests.CopyBackupRequest
  ): Promise<responses.CopyBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#copyBackup.");
    const operationName = "copyBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/CopyBackup";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": copyBackupRequest.ifMatch,
      "opc-request-id": copyBackupRequest.opcRequestId,
      "opc-retry-token": copyBackupRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      copyBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/actions/copy",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        copyBackupRequest.copyBackupDetails,
        "CopyBackupDetails",
        model.CopyBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CopyBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: model.Backup,
        type: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Create a backup of a DB System.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateBackupRequest
   * @return CreateBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CreateBackup.ts.html |here} to see how to use CreateBackup API.
   */
  public async createBackup(
    createBackupRequest: requests.CreateBackupRequest
  ): Promise<responses.CreateBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#createBackup.");
    const operationName = "createBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/CreateBackup";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createBackupRequest.opcRequestId,
      "opc-retry-token": createBackupRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createBackupRequest.createBackupDetails,
        "CreateBackupDetails",
        model.CreateBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: model.Backup,
        type: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete a Backup.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteBackupRequest
   * @return DeleteBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteBackup.ts.html |here} to see how to use DeleteBackup API.
   */
  public async deleteBackup(
    deleteBackupRequest: requests.DeleteBackupRequest
  ): Promise<responses.DeleteBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#deleteBackup.");
    const operationName = "deleteBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/DeleteBackup";
    const pathParams = {
      "{backupId}": deleteBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteBackupRequest.ifMatch,
      "opc-request-id": deleteBackupRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get information about the specified Backup
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetBackupRequest
   * @return GetBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetBackup.ts.html |here} to see how to use GetBackup API.
   */
  public async getBackup(
    getBackupRequest: requests.GetBackupRequest
  ): Promise<responses.GetBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#getBackup.");
    const operationName = "getBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/GetBackup";
    const pathParams = {
      "{backupId}": getBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getBackupRequest.opcRequestId,
      "if-none-match": getBackupRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: model.Backup,
        type: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get a list of DB System backups.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListBackupsRequest
   * @return ListBackupsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListBackups.ts.html |here} to see how to use ListBackups API.
   */
  public async listBackups(
    listBackupsRequest: requests.ListBackupsRequest
  ): Promise<responses.ListBackupsResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#listBackups.");
    const operationName = "listBackups";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/BackupSummary/ListBackups";
    const pathParams = {};

    const queryParams = {
      "backupId": listBackupsRequest.backupId,
      "lifecycleState": listBackupsRequest.lifecycleState,
      "compartmentId": listBackupsRequest.compartmentId,
      "dbSystemId": listBackupsRequest.dbSystemId,
      "displayName": listBackupsRequest.displayName,
      "softDelete": listBackupsRequest.softDelete,
      "backupPreparationStatus": listBackupsRequest.backupPreparationStatus,
      "validationStatus": listBackupsRequest.validationStatus,
      "creationType": listBackupsRequest.creationType,
      "sortBy": listBackupsRequest.sortBy,
      "sortOrder": listBackupsRequest.sortOrder,
      "limit": listBackupsRequest.limit,
      "page": listBackupsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listBackupsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listBackupsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBackupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.BackupSummary,
        type: "Array<model.BackupSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listBackupsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.BackupSummary objects
   * contained in responses from the listBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackups(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<model.BackupSummary> {
    return paginateRecords(request, req => this.listBackups(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listBackupsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllBackupsResponses(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<responses.ListBackupsResponse> {
    return paginateResponses(request, req => this.listBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.BackupSummary objects
   * contained in responses from the listBackups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listBackupsRecordIterator(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<model.BackupSummary> {
    return paginateRecords(request, req => this.listBackups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listBackups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listBackupsResponseIterator(
    request: requests.ListBackupsRequest
  ): AsyncIterableIterator<responses.ListBackupsResponse> {
    return paginateResponses(request, req => this.listBackups(req));
  }

  /**
   * Update the metadata of a Backup. Metadata such as the displayName or description
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateBackupRequest
   * @return UpdateBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateBackup.ts.html |here} to see how to use UpdateBackup API.
   */
  public async updateBackup(
    updateBackupRequest: requests.UpdateBackupRequest
  ): Promise<responses.UpdateBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#updateBackup.");
    const operationName = "updateBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/UpdateBackup";
    const pathParams = {
      "{backupId}": updateBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateBackupRequest.ifMatch,
      "opc-request-id": updateBackupRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateBackupRequest.updateBackupDetails,
        "UpdateBackupDetails",
        model.UpdateBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: model.Backup,
        type: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Request to validate the backup by checking the data consistency.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ValidateBackupRequest
   * @return ValidateBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ValidateBackup.ts.html |here} to see how to use ValidateBackup API.
   */
  public async validateBackup(
    validateBackupRequest: requests.ValidateBackupRequest
  ): Promise<responses.ValidateBackupResponse> {
    if (this.logger) this.logger.debug("Calling operation DbBackupsClient#validateBackup.");
    const operationName = "validateBackup";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Backup/ValidateBackup";
    const pathParams = {
      "{backupId}": validateBackupRequest.backupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": validateBackupRequest.ifMatch,
      "opc-request-id": validateBackupRequest.opcRequestId,
      "opc-retry-token": validateBackupRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      validateBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/backups/{backupId}/actions/validate",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        validateBackupRequest.validateBackupDetails,
        "ValidateBackupDetails",
        model.ValidateBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateBackupResponse>{},
        body: await response.json(),
        bodyKey: "backup",
        bodyModel: model.Backup,
        type: "model.Backup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum DbSystemApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class DbSystemClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DbSystemWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "DbSystem";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`DbSystemClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        DbSystemClient.serviceEndpointTemplate,
        this._region,
        DbSystemClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        DbSystemClient.serviceEndpointTemplate,
        this._regionId,
        DbSystemClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DbSystemClient.serviceEndpointTemplate,
      region,
      DbSystemClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DbSystemClient.serviceEndpointTemplate,
      regionId,
      DbSystemClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new DbSystemWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DbSystemWaiter {
    this._waiters = new DbSystemWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DbSystemWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Adds a HeatWave cluster to the DB System.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param AddHeatWaveClusterRequest
   * @return AddHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/AddHeatWaveCluster.ts.html |here} to see how to use AddHeatWaveCluster API.
   */
  public async addHeatWaveCluster(
    addHeatWaveClusterRequest: requests.AddHeatWaveClusterRequest
  ): Promise<responses.AddHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#addHeatWaveCluster.");
    const operationName = "addHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/AddHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": addHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": addHeatWaveClusterRequest.ifMatch,
      "opc-request-id": addHeatWaveClusterRequest.opcRequestId,
      "opc-retry-token": addHeatWaveClusterRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      addHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster/actions/add",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        addHeatWaveClusterRequest.addHeatWaveClusterDetails,
        "AddHeatWaveClusterDetails",
        model.AddHeatWaveClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.AddHeatWaveClusterResponse>{},
        body: await response.json(),
        bodyKey: "heatWaveCluster",
        bodyModel: model.HeatWaveCluster,
        type: "model.HeatWaveCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates and launches a DB System.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateDbSystemRequest
   * @return CreateDbSystemResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CreateDbSystem.ts.html |here} to see how to use CreateDbSystem API.
   */
  public async createDbSystem(
    createDbSystemRequest: requests.CreateDbSystemRequest
  ): Promise<responses.CreateDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#createDbSystem.");
    const operationName = "createDbSystem";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createDbSystemRequest.opcRequestId,
      "opc-retry-token": createDbSystemRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDbSystemRequest.createDbSystemDetails,
        "CreateDbSystemDetails",
        model.CreateDbSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDbSystemResponse>{},
        body: await response.json(),
        bodyKey: "dbSystem",
        bodyModel: model.DbSystem,
        type: "model.DbSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Delete a DB System, including terminating, detaching,
   * removing, finalizing and otherwise deleting all related resources.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteDbSystemRequest
   * @return DeleteDbSystemResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteDbSystem.ts.html |here} to see how to use DeleteDbSystem API.
   */
  public async deleteDbSystem(
    deleteDbSystemRequest: requests.DeleteDbSystemRequest
  ): Promise<responses.DeleteDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#deleteDbSystem.");
    const operationName = "deleteDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/DeleteDbSystem";
    const pathParams = {
      "{dbSystemId}": deleteDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteDbSystemRequest.ifMatch,
      "opc-request-id": deleteDbSystemRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the HeatWave cluster including terminating, detaching, removing, finalizing and
   * otherwise deleting all related resources.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteHeatWaveClusterRequest
   * @return DeleteHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteHeatWaveCluster.ts.html |here} to see how to use DeleteHeatWaveCluster API.
   */
  public async deleteHeatWaveCluster(
    deleteHeatWaveClusterRequest: requests.DeleteHeatWaveClusterRequest
  ): Promise<responses.DeleteHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#deleteHeatWaveCluster.");
    const operationName = "deleteHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/DeleteHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": deleteHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteHeatWaveClusterRequest.ifMatch,
      "opc-request-id": deleteHeatWaveClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteHeatWaveClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Sends a request to estimate the memory footprints of user tables when loaded to HeatWave cluster memory.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GenerateHeatWaveClusterMemoryEstimateRequest
   * @return GenerateHeatWaveClusterMemoryEstimateResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GenerateHeatWaveClusterMemoryEstimate.ts.html |here} to see how to use GenerateHeatWaveClusterMemoryEstimate API.
   */
  public async generateHeatWaveClusterMemoryEstimate(
    generateHeatWaveClusterMemoryEstimateRequest: requests.GenerateHeatWaveClusterMemoryEstimateRequest
  ): Promise<responses.GenerateHeatWaveClusterMemoryEstimateResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DbSystemClient#generateHeatWaveClusterMemoryEstimate.");
    const operationName = "generateHeatWaveClusterMemoryEstimate";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveClusterMemoryEstimate/GenerateHeatWaveClusterMemoryEstimate";
    const pathParams = {
      "{dbSystemId}": generateHeatWaveClusterMemoryEstimateRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": generateHeatWaveClusterMemoryEstimateRequest.opcRequestId,
      "opc-retry-token": generateHeatWaveClusterMemoryEstimateRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      generateHeatWaveClusterMemoryEstimateRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveClusterMemoryEstimate/actions/generate",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateHeatWaveClusterMemoryEstimateResponse>{},
        body: await response.json(),
        bodyKey: "heatWaveClusterMemoryEstimate",
        bodyModel: model.HeatWaveClusterMemoryEstimate,
        type: "model.HeatWaveClusterMemoryEstimate",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get information about the specified DB System.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetDbSystemRequest
   * @return GetDbSystemResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetDbSystem.ts.html |here} to see how to use GetDbSystem API.
   */
  public async getDbSystem(
    getDbSystemRequest: requests.GetDbSystemRequest
  ): Promise<responses.GetDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#getDbSystem.");
    const operationName = "getDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/GetDbSystem";
    const pathParams = {
      "{dbSystemId}": getDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getDbSystemRequest.opcRequestId,
      "if-none-match": getDbSystemRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDbSystemResponse>{},
        body: await response.json(),
        bodyKey: "dbSystem",
        bodyModel: model.DbSystem,
        type: "model.DbSystem",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about the HeatWave cluster.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetHeatWaveClusterRequest
   * @return GetHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetHeatWaveCluster.ts.html |here} to see how to use GetHeatWaveCluster API.
   */
  public async getHeatWaveCluster(
    getHeatWaveClusterRequest: requests.GetHeatWaveClusterRequest
  ): Promise<responses.GetHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#getHeatWaveCluster.");
    const operationName = "getHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/GetHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": getHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getHeatWaveClusterRequest.opcRequestId,
      "if-none-match": getHeatWaveClusterRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHeatWaveClusterResponse>{},
        body: await response.json(),
        bodyKey: "heatWaveCluster",
        bodyModel: model.HeatWaveCluster,
        type: "model.HeatWaveCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the most recent HeatWave cluster memory estimate that can be used to determine a suitable
   * HeatWave cluster size.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetHeatWaveClusterMemoryEstimateRequest
   * @return GetHeatWaveClusterMemoryEstimateResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetHeatWaveClusterMemoryEstimate.ts.html |here} to see how to use GetHeatWaveClusterMemoryEstimate API.
   */
  public async getHeatWaveClusterMemoryEstimate(
    getHeatWaveClusterMemoryEstimateRequest: requests.GetHeatWaveClusterMemoryEstimateRequest
  ): Promise<responses.GetHeatWaveClusterMemoryEstimateResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DbSystemClient#getHeatWaveClusterMemoryEstimate.");
    const operationName = "getHeatWaveClusterMemoryEstimate";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveClusterMemoryEstimate/GetHeatWaveClusterMemoryEstimate";
    const pathParams = {
      "{dbSystemId}": getHeatWaveClusterMemoryEstimateRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getHeatWaveClusterMemoryEstimateRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getHeatWaveClusterMemoryEstimateRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveClusterMemoryEstimate",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetHeatWaveClusterMemoryEstimateResponse>{},
        body: await response.json(),
        bodyKey: "heatWaveClusterMemoryEstimate",
        bodyModel: model.HeatWaveClusterMemoryEstimate,
        type: "model.HeatWaveClusterMemoryEstimate",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get a list of DB Systems in the specified compartment.
   * The default sort order is by timeUpdated, descending.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListDbSystemsRequest
   * @return ListDbSystemsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListDbSystems.ts.html |here} to see how to use ListDbSystems API.
   */
  public async listDbSystems(
    listDbSystemsRequest: requests.ListDbSystemsRequest
  ): Promise<responses.ListDbSystemsResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#listDbSystems.");
    const operationName = "listDbSystems";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystemSummary/ListDbSystems";
    const pathParams = {};

    const queryParams = {
      "isHeatWaveClusterAttached": listDbSystemsRequest.isHeatWaveClusterAttached,
      "compartmentId": listDbSystemsRequest.compartmentId,
      "dbSystemId": listDbSystemsRequest.dbSystemId,
      "displayName": listDbSystemsRequest.displayName,
      "lifecycleState": listDbSystemsRequest.lifecycleState,
      "configurationId": listDbSystemsRequest.configurationId,
      "isUpToDate": listDbSystemsRequest.isUpToDate,
      "databaseManagement": listDbSystemsRequest.databaseManagement,
      "sortBy": listDbSystemsRequest.sortBy,
      "sortOrder": listDbSystemsRequest.sortOrder,
      "limit": listDbSystemsRequest.limit,
      "page": listDbSystemsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listDbSystemsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listDbSystemsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDbSystemsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.DbSystemSummary,
        type: "Array<model.DbSystemSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listDbSystemsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.DbSystemSummary objects
   * contained in responses from the listDbSystems operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystems(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<model.DbSystemSummary> {
    return paginateRecords(request, req => this.listDbSystems(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listDbSystemsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listDbSystems operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDbSystemsResponses(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<responses.ListDbSystemsResponse> {
    return paginateResponses(request, req => this.listDbSystems(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.DbSystemSummary objects
   * contained in responses from the listDbSystems operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listDbSystemsRecordIterator(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<model.DbSystemSummary> {
    return paginateRecords(request, req => this.listDbSystems(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDbSystems operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listDbSystemsResponseIterator(
    request: requests.ListDbSystemsRequest
  ): AsyncIterableIterator<responses.ListDbSystemsResponse> {
    return paginateResponses(request, req => this.listDbSystems(req));
  }

  /**
   * Restarts the specified DB System.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param RestartDbSystemRequest
   * @return RestartDbSystemResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/RestartDbSystem.ts.html |here} to see how to use RestartDbSystem API.
   */
  public async restartDbSystem(
    restartDbSystemRequest: requests.RestartDbSystemRequest
  ): Promise<responses.RestartDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#restartDbSystem.");
    const operationName = "restartDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/RestartDbSystem";
    const pathParams = {
      "{dbSystemId}": restartDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": restartDbSystemRequest.ifMatch,
      "opc-request-id": restartDbSystemRequest.opcRequestId,
      "opc-retry-token": restartDbSystemRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restartDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/actions/restart",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        restartDbSystemRequest.restartDbSystemDetails,
        "RestartDbSystemDetails",
        model.RestartDbSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestartDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Restarts the HeatWave cluster.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param RestartHeatWaveClusterRequest
   * @return RestartHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/RestartHeatWaveCluster.ts.html |here} to see how to use RestartHeatWaveCluster API.
   */
  public async restartHeatWaveCluster(
    restartHeatWaveClusterRequest: requests.RestartHeatWaveClusterRequest
  ): Promise<responses.RestartHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#restartHeatWaveCluster.");
    const operationName = "restartHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/RestartHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": restartHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": restartHeatWaveClusterRequest.ifMatch,
      "opc-request-id": restartHeatWaveClusterRequest.opcRequestId,
      "opc-retry-token": restartHeatWaveClusterRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      restartHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster/actions/restart",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.RestartHeatWaveClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Start the specified DB System.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param StartDbSystemRequest
   * @return StartDbSystemResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/StartDbSystem.ts.html |here} to see how to use StartDbSystem API.
   */
  public async startDbSystem(
    startDbSystemRequest: requests.StartDbSystemRequest
  ): Promise<responses.StartDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#startDbSystem.");
    const operationName = "startDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/StartDbSystem";
    const pathParams = {
      "{dbSystemId}": startDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": startDbSystemRequest.ifMatch,
      "opc-request-id": startDbSystemRequest.opcRequestId,
      "opc-retry-token": startDbSystemRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      startDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.StartDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Starts the HeatWave cluster.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param StartHeatWaveClusterRequest
   * @return StartHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/StartHeatWaveCluster.ts.html |here} to see how to use StartHeatWaveCluster API.
   */
  public async startHeatWaveCluster(
    startHeatWaveClusterRequest: requests.StartHeatWaveClusterRequest
  ): Promise<responses.StartHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#startHeatWaveCluster.");
    const operationName = "startHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/StartHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": startHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": startHeatWaveClusterRequest.ifMatch,
      "opc-request-id": startHeatWaveClusterRequest.opcRequestId,
      "opc-retry-token": startHeatWaveClusterRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      startHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster/actions/start",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.StartHeatWaveClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Stops the specified DB System.
* <p>
A stopped DB System is not billed.
* 
     * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
     * @param StopDbSystemRequest
     * @return StopDbSystemResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/StopDbSystem.ts.html |here} to see how to use StopDbSystem API.
     */
  public async stopDbSystem(
    stopDbSystemRequest: requests.StopDbSystemRequest
  ): Promise<responses.StopDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#stopDbSystem.");
    const operationName = "stopDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/StopDbSystem";
    const pathParams = {
      "{dbSystemId}": stopDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": stopDbSystemRequest.ifMatch,
      "opc-request-id": stopDbSystemRequest.opcRequestId,
      "opc-retry-token": stopDbSystemRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      stopDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/actions/stop",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        stopDbSystemRequest.stopDbSystemDetails,
        "StopDbSystemDetails",
        model.StopDbSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.StopDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Stops the HeatWave cluster.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param StopHeatWaveClusterRequest
   * @return StopHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/StopHeatWaveCluster.ts.html |here} to see how to use StopHeatWaveCluster API.
   */
  public async stopHeatWaveCluster(
    stopHeatWaveClusterRequest: requests.StopHeatWaveClusterRequest
  ): Promise<responses.StopHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#stopHeatWaveCluster.");
    const operationName = "stopHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/StopHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": stopHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": stopHeatWaveClusterRequest.ifMatch,
      "opc-request-id": stopHeatWaveClusterRequest.opcRequestId,
      "opc-retry-token": stopHeatWaveClusterRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      stopHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster/actions/stop",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.StopHeatWaveClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Update the configuration of a DB System.
* <p>
Updating different fields in the DB System will have different results
* on the uptime of the DB System. For example, changing the displayName of
* a DB System will take effect immediately, but changing the shape of a
* DB System is an asynchronous operation that involves provisioning new
* Compute resources, pausing the DB System and migrating storage
* before making the DB System available again.
* 
     * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
     * @param UpdateDbSystemRequest
     * @return UpdateDbSystemResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateDbSystem.ts.html |here} to see how to use UpdateDbSystem API.
     */
  public async updateDbSystem(
    updateDbSystemRequest: requests.UpdateDbSystemRequest
  ): Promise<responses.UpdateDbSystemResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#updateDbSystem.");
    const operationName = "updateDbSystem";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/DbSystem/UpdateDbSystem";
    const pathParams = {
      "{dbSystemId}": updateDbSystemRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateDbSystemRequest.ifMatch,
      "opc-request-id": updateDbSystemRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateDbSystemRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDbSystemRequest.updateDbSystemDetails,
        "UpdateDbSystemDetails",
        model.UpdateDbSystemDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDbSystemResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the HeatWave cluster.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateHeatWaveClusterRequest
   * @return UpdateHeatWaveClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateHeatWaveCluster.ts.html |here} to see how to use UpdateHeatWaveCluster API.
   */
  public async updateHeatWaveCluster(
    updateHeatWaveClusterRequest: requests.UpdateHeatWaveClusterRequest
  ): Promise<responses.UpdateHeatWaveClusterResponse> {
    if (this.logger) this.logger.debug("Calling operation DbSystemClient#updateHeatWaveCluster.");
    const operationName = "updateHeatWaveCluster";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/HeatWaveCluster/UpdateHeatWaveCluster";
    const pathParams = {
      "{dbSystemId}": updateHeatWaveClusterRequest.dbSystemId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateHeatWaveClusterRequest.ifMatch,
      "opc-request-id": updateHeatWaveClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateHeatWaveClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dbSystems/{dbSystemId}/heatWaveCluster",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateHeatWaveClusterRequest.updateHeatWaveClusterDetails,
        "UpdateHeatWaveClusterDetails",
        model.UpdateHeatWaveClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateHeatWaveClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum MysqlaasApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class MysqlaasClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": MysqlaasWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "Mysqlaas";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`MysqlaasClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        MysqlaasClient.serviceEndpointTemplate,
        this._region,
        MysqlaasClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        MysqlaasClient.serviceEndpointTemplate,
        this._regionId,
        MysqlaasClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      MysqlaasClient.serviceEndpointTemplate,
      region,
      MysqlaasClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      MysqlaasClient.serviceEndpointTemplate,
      regionId,
      MysqlaasClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new MysqlaasWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): MysqlaasWaiter {
    this._waiters = new MysqlaasWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): MysqlaasWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Creates a new Configuration.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CreateConfigurationRequest
   * @return CreateConfigurationResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CreateConfiguration.ts.html |here} to see how to use CreateConfiguration API.
   */
  public async createConfiguration(
    createConfigurationRequest: requests.CreateConfigurationRequest
  ): Promise<responses.CreateConfigurationResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#createConfiguration.");
    const operationName = "createConfiguration";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createConfigurationRequest.opcRequestId,
      "opc-retry-token": createConfigurationRequest.opcRetryToken
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createConfigurationRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/configurations",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createConfigurationRequest.createConfigurationDetails,
        "CreateConfigurationDetails",
        model.CreateConfigurationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "configuration",
        bodyModel: model.Configuration,
        type: "model.Configuration",
        responseHeaders: [
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a Configuration.
   * The Configuration must not be in use by any DB Systems.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteConfigurationRequest
   * @return DeleteConfigurationResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteConfiguration.ts.html |here} to see how to use DeleteConfiguration API.
   */
  public async deleteConfiguration(
    deleteConfigurationRequest: requests.DeleteConfigurationRequest
  ): Promise<responses.DeleteConfigurationResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#deleteConfiguration.");
    const operationName = "deleteConfiguration";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Configuration/DeleteConfiguration";
    const pathParams = {
      "{configurationId}": deleteConfigurationRequest.configurationId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteConfigurationRequest.ifMatch,
      "opc-request-id": deleteConfigurationRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteConfigurationRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/configurations/{configurationId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteConfigurationResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Get the full details of the specified Configuration, including the list of MySQL Variables and their values.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetConfigurationRequest
   * @return GetConfigurationResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetConfiguration.ts.html |here} to see how to use GetConfiguration API.
   */
  public async getConfiguration(
    getConfigurationRequest: requests.GetConfigurationRequest
  ): Promise<responses.GetConfigurationResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#getConfiguration.");
    const operationName = "getConfiguration";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Configuration/GetConfiguration";
    const pathParams = {
      "{configurationId}": getConfigurationRequest.configurationId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getConfigurationRequest.opcRequestId,
      "if-none-match": getConfigurationRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getConfigurationRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/configurations/{configurationId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "configuration",
        bodyModel: model.Configuration,
        type: "model.Configuration",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Lists the Configurations available when creating a DB System.
* <p>
This may include DEFAULT configurations per Shape and CUSTOM configurations.
* <p>
The default sort order is a multi-part sort by:
*   - shapeName, ascending
*   - DEFAULT-before-CUSTOM
*   - displayName ascending
* 
     * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
     * @param ListConfigurationsRequest
     * @return ListConfigurationsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListConfigurations.ts.html |here} to see how to use ListConfigurations API.
     */
  public async listConfigurations(
    listConfigurationsRequest: requests.ListConfigurationsRequest
  ): Promise<responses.ListConfigurationsResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#listConfigurations.");
    const operationName = "listConfigurations";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/ConfigurationSummary/ListConfigurations";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listConfigurationsRequest.compartmentId,
      "configurationId": listConfigurationsRequest.configurationId,
      "lifecycleState": listConfigurationsRequest.lifecycleState,
      "type": listConfigurationsRequest.type,
      "displayName": listConfigurationsRequest.displayName,
      "shapeName": listConfigurationsRequest.shapeName,
      "sortBy": listConfigurationsRequest.sortBy,
      "sortOrder": listConfigurationsRequest.sortOrder,
      "limit": listConfigurationsRequest.limit,
      "page": listConfigurationsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listConfigurationsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listConfigurationsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/configurations",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListConfigurationsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.ConfigurationSummary,
        type: "Array<model.ConfigurationSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listConfigurationsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.ConfigurationSummary objects
   * contained in responses from the listConfigurations operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConfigurations(
    request: requests.ListConfigurationsRequest
  ): AsyncIterableIterator<model.ConfigurationSummary> {
    return paginateRecords(request, req => this.listConfigurations(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listConfigurationsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listConfigurations operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllConfigurationsResponses(
    request: requests.ListConfigurationsRequest
  ): AsyncIterableIterator<responses.ListConfigurationsResponse> {
    return paginateResponses(request, req => this.listConfigurations(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.ConfigurationSummary objects
   * contained in responses from the listConfigurations operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listConfigurationsRecordIterator(
    request: requests.ListConfigurationsRequest
  ): AsyncIterableIterator<model.ConfigurationSummary> {
    return paginateRecords(request, req => this.listConfigurations(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listConfigurations operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listConfigurationsResponseIterator(
    request: requests.ListConfigurationsRequest
  ): AsyncIterableIterator<responses.ListConfigurationsResponse> {
    return paginateResponses(request, req => this.listConfigurations(req));
  }

  /**
   * Gets a list of the shapes you can use to create a new MySQL DB System.
   * The shape determines the resources allocated to the DB System:
   * CPU cores and memory for VM shapes; CPU cores, memory and
   * storage for non-VM (or bare metal) shapes.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListShapesRequest
   * @return ListShapesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListShapes.ts.html |here} to see how to use ListShapes API.
   */
  public async listShapes(
    listShapesRequest: requests.ListShapesRequest
  ): Promise<responses.ListShapesResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#listShapes.");
    const operationName = "listShapes";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes";
    const pathParams = {};

    const queryParams = {
      "isSupportedFor": listShapesRequest.isSupportedFor,
      "availabilityDomain": listShapesRequest.availabilityDomain,
      "compartmentId": listShapesRequest.compartmentId,
      "name": listShapesRequest.name
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listShapesRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listShapesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/shapes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListShapesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.ShapeSummary,
        type: "Array<model.ShapeSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Get a list of supported and available MySQL database major versions.
* <p>
The list is sorted by version family.
* 
     * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
     * @param ListVersionsRequest
     * @return ListVersionsResponse
     * @throws OciError when an error occurs
     * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListVersions.ts.html |here} to see how to use ListVersions API.
     */
  public async listVersions(
    listVersionsRequest: requests.ListVersionsRequest
  ): Promise<responses.ListVersionsResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#listVersions.");
    const operationName = "listVersions";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/VersionSummary/ListVersions";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listVersionsRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listVersionsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listVersionsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/versions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListVersionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.VersionSummary,
        type: "Array<model.VersionSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the Configuration details.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateConfigurationRequest
   * @return UpdateConfigurationResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateConfiguration.ts.html |here} to see how to use UpdateConfiguration API.
   */
  public async updateConfiguration(
    updateConfigurationRequest: requests.UpdateConfigurationRequest
  ): Promise<responses.UpdateConfigurationResponse> {
    if (this.logger) this.logger.debug("Calling operation MysqlaasClient#updateConfiguration.");
    const operationName = "updateConfiguration";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Configuration/UpdateConfiguration";
    const pathParams = {
      "{configurationId}": updateConfigurationRequest.configurationId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateConfigurationRequest.ifMatch,
      "opc-request-id": updateConfigurationRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateConfigurationRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/configurations/{configurationId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateConfigurationRequest.updateConfigurationDetails,
        "UpdateConfigurationDetails",
        model.UpdateConfigurationDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateConfigurationResponse>{},
        body: await response.json(),
        bodyKey: "configuration",
        bodyModel: model.Configuration,
        type: "model.Configuration",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum ReplicasApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class ReplicasClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": ReplicasWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "Replicas";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`ReplicasClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        ReplicasClient.serviceEndpointTemplate,
        this._region,
        ReplicasClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        ReplicasClient.serviceEndpointTemplate,
        this._regionId,
        ReplicasClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      ReplicasClient.serviceEndpointTemplate,
      region,
      ReplicasClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      ReplicasClient.serviceEndpointTemplate,
      regionId,
      ReplicasClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new ReplicasWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): ReplicasWaiter {
    this._waiters = new ReplicasWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): ReplicasWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Creates a DB System read replica.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param CreateReplicaRequest
   * @return CreateReplicaResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/CreateReplica.ts.html |here} to see how to use CreateReplica API.
   */
  public async createReplica(
    createReplicaRequest: requests.CreateReplicaRequest
  ): Promise<responses.CreateReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation ReplicasClient#createReplica.");
    const operationName = "createReplica";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": createReplicaRequest.opcRequestId,
      "opc-retry-token": createReplicaRequest.opcRetryToken
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/replicas",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createReplicaRequest.createReplicaDetails,
        "CreateReplicaDetails",
        model.CreateReplicaDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateReplicaResponse>{},
        body: await response.json(),
        bodyKey: "replica",
        bodyModel: model.Replica,
        type: "model.Replica",
        responseHeaders: [
          {
            value: response.headers.get("location"),
            key: "location",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified read replica.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param DeleteReplicaRequest
   * @return DeleteReplicaResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/DeleteReplica.ts.html |here} to see how to use DeleteReplica API.
   */
  public async deleteReplica(
    deleteReplicaRequest: requests.DeleteReplicaRequest
  ): Promise<responses.DeleteReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation ReplicasClient#deleteReplica.");
    const operationName = "deleteReplica";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Replica/DeleteReplica";
    const pathParams = {
      "{replicaId}": deleteReplicaRequest.replicaId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteReplicaRequest.ifMatch,
      "opc-request-id": deleteReplicaRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/replicas/{replicaId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteReplicaResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the full details of the specified read replica.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetReplicaRequest
   * @return GetReplicaResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetReplica.ts.html |here} to see how to use GetReplica API.
   */
  public async getReplica(
    getReplicaRequest: requests.GetReplicaRequest
  ): Promise<responses.GetReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation ReplicasClient#getReplica.");
    const operationName = "getReplica";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Replica/GetReplica";
    const pathParams = {
      "{replicaId}": getReplicaRequest.replicaId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getReplicaRequest.opcRequestId,
      "if-none-match": getReplicaRequest.ifNoneMatch
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/replicas/{replicaId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetReplicaResponse>{},
        body: await response.json(),
        bodyKey: "replica",
        bodyModel: model.Replica,
        type: "model.Replica",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists all the read replicas that match the specified filters.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListReplicasRequest
   * @return ListReplicasResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListReplicas.ts.html |here} to see how to use ListReplicas API.
   */
  public async listReplicas(
    listReplicasRequest: requests.ListReplicasRequest
  ): Promise<responses.ListReplicasResponse> {
    if (this.logger) this.logger.debug("Calling operation ReplicasClient#listReplicas.");
    const operationName = "listReplicas";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/ReplicaSummary/ListReplicas";
    const pathParams = {};

    const queryParams = {
      "limit": listReplicasRequest.limit,
      "page": listReplicasRequest.page,
      "displayName": listReplicasRequest.displayName,
      "dbSystemId": listReplicasRequest.dbSystemId,
      "compartmentId": listReplicasRequest.compartmentId,
      "lifecycleState": listReplicasRequest.lifecycleState,
      "replicaId": listReplicasRequest.replicaId,
      "configurationId": listReplicasRequest.configurationId,
      "isUpToDate": listReplicasRequest.isUpToDate,
      "sortBy": listReplicasRequest.sortBy,
      "sortOrder": listReplicasRequest.sortOrder
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listReplicasRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listReplicasRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/replicas",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListReplicasResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.ReplicaSummary,
        type: "Array<model.ReplicaSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listReplicasRecordIterator function.
   * Creates a new async iterator which will iterate over the models.ReplicaSummary objects
   * contained in responses from the listReplicas operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicas(
    request: requests.ListReplicasRequest
  ): AsyncIterableIterator<model.ReplicaSummary> {
    return paginateRecords(request, req => this.listReplicas(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listReplicasResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listReplicas operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllReplicasResponses(
    request: requests.ListReplicasRequest
  ): AsyncIterableIterator<responses.ListReplicasResponse> {
    return paginateResponses(request, req => this.listReplicas(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.ReplicaSummary objects
   * contained in responses from the listReplicas operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listReplicasRecordIterator(
    request: requests.ListReplicasRequest
  ): AsyncIterableIterator<model.ReplicaSummary> {
    return paginateRecords(request, req => this.listReplicas(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listReplicas operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listReplicasResponseIterator(
    request: requests.ListReplicasRequest
  ): AsyncIterableIterator<responses.ListReplicasResponse> {
    return paginateResponses(request, req => this.listReplicas(req));
  }

  /**
   * Updates the properties of the specified read replica.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param UpdateReplicaRequest
   * @return UpdateReplicaResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/UpdateReplica.ts.html |here} to see how to use UpdateReplica API.
   */
  public async updateReplica(
    updateReplicaRequest: requests.UpdateReplicaRequest
  ): Promise<responses.UpdateReplicaResponse> {
    if (this.logger) this.logger.debug("Calling operation ReplicasClient#updateReplica.");
    const operationName = "updateReplica";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/Replica/UpdateReplica";
    const pathParams = {
      "{replicaId}": updateReplicaRequest.replicaId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateReplicaRequest.ifMatch,
      "opc-request-id": updateReplicaRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateReplicaRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/replicas/{replicaId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateReplicaRequest.updateReplicaDetails,
        "UpdateReplicaDetails",
        model.UpdateReplicaDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateReplicaResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum WorkRequestsApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class WorkRequestsClient {
  protected static serviceEndpointTemplate = "https://mysql.{region}.ocp.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": WorkRequestsWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "WorkRequests";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("mysql")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("mysql");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20190415";
    if (this.logger) this.logger.info(`WorkRequestsClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        WorkRequestsClient.serviceEndpointTemplate,
        this._region,
        WorkRequestsClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        WorkRequestsClient.serviceEndpointTemplate,
        this._regionId,
        WorkRequestsClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      WorkRequestsClient.serviceEndpointTemplate,
      region,
      WorkRequestsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      WorkRequestsClient.serviceEndpointTemplate,
      regionId,
      WorkRequestsClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new WorkRequestsWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): WorkRequestsWaiter {
    this._waiters = new WorkRequestsWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): WorkRequestsWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Gets the status of the work request with the given ID.
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/GetWorkRequest.ts.html |here} to see how to use GetWorkRequest API.
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation WorkRequestsClient#getWorkRequest.");
    const operationName = "getWorkRequest";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/WorkRequest/GetWorkRequest";
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-none-match": getWorkRequestRequest.ifNoneMatch,
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getWorkRequestRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: model.WorkRequest,
        type: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("Retry-After"),
            key: "retryAfter",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListWorkRequestErrors.ts.html |here} to see how to use ListWorkRequestErrors API.
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation WorkRequestsClient#listWorkRequestErrors.");
    const operationName = "listWorkRequestErrors";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/WorkRequestError/ListWorkRequestErrors";
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "limit": listWorkRequestErrorsRequest.limit,
      "page": listWorkRequestErrorsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestErrorsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.WorkRequestError,
        type: "Array<model.WorkRequestError>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestErrorsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrors(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<model.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestErrorsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestErrorsResponses(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestError objects
   * contained in responses from the listWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestErrorsRecordIterator(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<model.WorkRequestError> {
    return paginateRecords(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestErrorsResponseIterator(
    request: requests.ListWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listWorkRequestErrors(req));
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListWorkRequestLogs.ts.html |here} to see how to use ListWorkRequestLogs API.
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger) this.logger.debug("Calling operation WorkRequestsClient#listWorkRequestLogs.");
    const operationName = "listWorkRequestLogs";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/WorkRequestLogEntry/ListWorkRequestLogs";
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "limit": listWorkRequestLogsRequest.limit,
      "page": listWorkRequestLogsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestLogsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.WorkRequestLogEntry,
        type: "Array<model.WorkRequestLogEntry>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestLogsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.WorkRequestLogEntry objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogs(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<model.WorkRequestLogEntry> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestLogsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestLogsResponses(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestLogEntry objects
   * contained in responses from the listWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestLogsRecordIterator(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<model.WorkRequestLogEntry> {
    return paginateRecords(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestLogsResponseIterator(
    request: requests.ListWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listWorkRequestLogs(req));
  }

  /**
   * Lists the work requests in a specified compartment.
   *
   * This operation uses {@link common.OciSdkDefaultRetryConfiguration} by default if no retry configuration is defined by the user.
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/mysql/ListWorkRequests.ts.html |here} to see how to use ListWorkRequests API.
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger) this.logger.debug("Calling operation WorkRequestsClient#listWorkRequests.");
    const operationName = "listWorkRequests";
    const apiReferenceLink =
      "https://docs.oracle.com/iaas/api/#/en/mysql/20190415/WorkRequestSummary/ListWorkRequests";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "sortBy": listWorkRequestsRequest.sortBy,
      "sortOrder": listWorkRequestsRequest.sortOrder,
      "limit": listWorkRequestsRequest.limit,
      "page": listWorkRequestsRequest.page
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const specRetryConfiguration = common.OciSdkDefaultRetryConfiguration;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: model.WorkRequestSummary,
        type: "Array<model.WorkRequestSummary>",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestsRecordIterator function.
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<model.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * NOTE: This function is deprecated in favor of listWorkRequestsResponseIterator function.
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestsRecordIterator(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<model.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listWorkRequestsResponseIterator(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }
}
