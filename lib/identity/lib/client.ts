/**
 * Identity and Access Management Service API
 * APIs for managing users, groups, compartments, and policies.
 * OpenAPI spec version: 20160918
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { IdentityWaiter } from "./identity-waiter";
import { composeResponse, composeRequest } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum IdentityApiKeys {}

export class IdentityClient {
  protected static serviceEndpointTemplate = "https://identity.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": IdentityWaiter;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20160918";
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      IdentityClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      IdentityClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new IdentityWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): IdentityWaiter {
    this._waiters = new IdentityWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): IdentityWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Activates the specified MFA TOTP device for the user. Activation requires manual interaction with the Console.
   *
   * @param ActivateMfaTotpDeviceRequest
   * @return ActivateMfaTotpDeviceResponse
   * @throws OciError when an error occurs
   */
  public async activateMfaTotpDevice(
    activateMfaTotpDeviceRequest: requests.ActivateMfaTotpDeviceRequest
  ): Promise<responses.ActivateMfaTotpDeviceResponse> {
    const pathParams = {
      "{userId}": activateMfaTotpDeviceRequest.userId,
      "{mfaTotpDeviceId}": activateMfaTotpDeviceRequest.mfaTotpDeviceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": activateMfaTotpDeviceRequest.ifMatch,
      "opc-retry-token": activateMfaTotpDeviceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices/{mfaTotpDeviceId}/actions/activate",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        activateMfaTotpDeviceRequest.mfaTotpToken,
        "MfaTotpToken",
        models.MfaTotpToken.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ActivateMfaTotpDeviceResponse>{},
        body: await response.json(),
        bodyKey: "mfaTotpDeviceSummary",
        bodyModel: "model.MfaTotpDeviceSummary",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Adds the specified user to the specified group and returns a `UserGroupMembership` object with its own OCID.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* 
     * @param AddUserToGroupRequest
     * @return AddUserToGroupResponse
     * @throws OciError when an error occurs
     */
  public async addUserToGroup(
    addUserToGroupRequest: requests.AddUserToGroupRequest
  ): Promise<responses.AddUserToGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": addUserToGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/userGroupMemberships",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        addUserToGroupRequest.addUserToGroupDetails,
        "AddUserToGroupDetails",
        models.AddUserToGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AddUserToGroupResponse>{},
        body: await response.json(),
        bodyKey: "userGroupMembership",
        bodyModel: "model.UserGroupMembership",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Assembles tag defaults in the specified compartment and any parent compartments to determine
   * the tags to apply. Tag defaults from parent compartments do not override tag defaults
   * referencing the same tag in a compartment lower down the hierarchy. This set of tag defaults
   * includes all tag defaults from the current compartment back to the root compartment.
   *
   * @param AssembleEffectiveTagSetRequest
   * @return AssembleEffectiveTagSetResponse
   * @throws OciError when an error occurs
   */
  public async assembleEffectiveTagSet(
    assembleEffectiveTagSetRequest: requests.AssembleEffectiveTagSetRequest
  ): Promise<responses.AssembleEffectiveTagSetResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": assembleEffectiveTagSetRequest.compartmentId,
      "lifecycleState": assembleEffectiveTagSetRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults/actions/assembleEffectiveTagSet",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.AssembleEffectiveTagSetResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TagDefaultSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Bulk delete resources in the compartment. All resources must be in the same compartment.
   * This API can only be invoked from tenancy's home region.
   *
   * @param BulkDeleteResourcesRequest
   * @return BulkDeleteResourcesResponse
   * @throws OciError when an error occurs
   */
  public async bulkDeleteResources(
    bulkDeleteResourcesRequest: requests.BulkDeleteResourcesRequest
  ): Promise<responses.BulkDeleteResourcesResponse> {
    const pathParams = {
      "{compartmentId}": bulkDeleteResourcesRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": bulkDeleteResourcesRequest.opcRequestId,
      "opc-retry-token": bulkDeleteResourcesRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}/actions/bulkDeleteResources",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        bulkDeleteResourcesRequest.bulkDeleteResourcesDetails,
        "BulkDeleteResourcesDetails",
        models.BulkDeleteResourcesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BulkDeleteResourcesResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified tag key definitions. This operation triggers a process that removes the
* tags from all resources in your tenancy. 
* <p>
The following actions happen immediately:
* \u00A0
*   * If the tag is a cost-tracking tag, the tag no longer counts against your   
*   10 cost-tracking tags limit, even if you do not disable the tag before running this operation.
*   * If the tag is used with dynamic groups, the rules that contain the tag are no longer 
*   evaluated against the tag. 
* <p>
After you start this operation, the state of the tag changes to DELETING, and tag removal
* from resources begins. This process can take up to 48 hours depending on the number of resources that
* are tagged and the regions in which those resources reside. 
* <p>
When all tags have been removed, the state changes to DELETED. You cannot restore a deleted tag. After the tag state
* changes to DELETED, you can use the same tag name again.
* <p>
After you start this operation, you cannot start either the {@link #deleteTag(DeleteTagRequest) deleteTag} or the {@link #cascadeDeleteTagNamespace(CascadeDeleteTagNamespaceRequest) cascadeDeleteTagNamespace} operation until this process completes.
* <p>
In order to delete tags, you must first retire the tags. Use {@link #updateTag(UpdateTagRequest) updateTag}
* to retire a tag. 
* 
     * @param BulkDeleteTagsRequest
     * @return BulkDeleteTagsResponse
     * @throws OciError when an error occurs
     */
  public async bulkDeleteTags(
    bulkDeleteTagsRequest: requests.BulkDeleteTagsRequest
  ): Promise<responses.BulkDeleteTagsResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": bulkDeleteTagsRequest.opcRequestId,
      "opc-retry-token": bulkDeleteTagsRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tags/actions/bulkDelete",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        bulkDeleteTagsRequest.bulkDeleteTagsDetails,
        "BulkDeleteTagsDetails",
        models.BulkDeleteTagsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BulkDeleteTagsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Bulk move resources in the compartment. All resources must be in the same compartment.
   * This API can only be invoked from tenancy's home region.
   *
   * @param BulkMoveResourcesRequest
   * @return BulkMoveResourcesResponse
   * @throws OciError when an error occurs
   */
  public async bulkMoveResources(
    bulkMoveResourcesRequest: requests.BulkMoveResourcesRequest
  ): Promise<responses.BulkMoveResourcesResponse> {
    const pathParams = {
      "{compartmentId}": bulkMoveResourcesRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": bulkMoveResourcesRequest.opcRequestId,
      "opc-retry-token": bulkMoveResourcesRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}/actions/bulkMoveResources",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        bulkMoveResourcesRequest.bulkMoveResourcesDetails,
        "BulkMoveResourcesDetails",
        models.BulkMoveResourcesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.BulkMoveResourcesResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified tag namespace. This operation triggers a process that removes all of the tags 
* defined in the specified tag namespace from all resources in your tenancy and then deletes the tag namespace.
* <p>
After you start the delete operation: 
* <p>
  * New tag key definitions cannot be created under the namespace. 
*   * The state of the tag namespace changes to DELETING.
*   * Tag removal from the resources begins. 
* <p>
This process can take up to 48 hours depending on the number of tag definitions in the namespace, the number of resources 
* that are tagged, and the locations of the regions in which those resources reside.
* <p>
After all tags are removed, the state changes to DELETED. You cannot restore a deleted tag namespace. After the deleted tag namespace 
* changes its state to DELETED, you can use the name of the deleted tag namespace again.
* <p>
After you start this operation, you cannot start either the {@link #deleteTag(DeleteTagRequest) deleteTag} or the {@link #bulkDeleteTags(BulkDeleteTagsRequest) bulkDeleteTags} operation until this process completes.
* <p>
To delete a tag namespace, you must first retire it. Use {@link #updateTagNamespace(UpdateTagNamespaceRequest) updateTagNamespace}
* to retire a tag namespace.
* 
     * @param CascadeDeleteTagNamespaceRequest
     * @return CascadeDeleteTagNamespaceResponse
     * @throws OciError when an error occurs
     */
  public async cascadeDeleteTagNamespace(
    cascadeDeleteTagNamespaceRequest: requests.CascadeDeleteTagNamespaceRequest
  ): Promise<responses.CascadeDeleteTagNamespaceResponse> {
    const pathParams = {
      "{tagNamespaceId}": cascadeDeleteTagNamespaceRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": cascadeDeleteTagNamespaceRequest.ifMatch,
      "opc-request-id": cascadeDeleteTagNamespaceRequest.opcRequestId,
      "opc-retry-token": cascadeDeleteTagNamespaceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/actions/cascadeDelete",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CascadeDeleteTagNamespaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Moves the specified tag namespace to the specified compartment within the same tenancy.
* <p>
To move the tag namespace, you must have the manage tag-namespaces permission on both compartments.
* For more information about IAM policies, see [Details for IAM](https://docs.cloud.oracle.com/Content/Identity/Reference/iampolicyreference.htm).
* <p>
Moving a tag namespace moves all the tag key definitions contained in the tag namespace.
* 
     * @param ChangeTagNamespaceCompartmentRequest
     * @return ChangeTagNamespaceCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async changeTagNamespaceCompartment(
    changeTagNamespaceCompartmentRequest: requests.ChangeTagNamespaceCompartmentRequest
  ): Promise<responses.ChangeTagNamespaceCompartmentResponse> {
    const pathParams = {
      "{tagNamespaceId}": changeTagNamespaceCompartmentRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": changeTagNamespaceCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeTagNamespaceCompartmentRequest.changeTagNamespaceCompartmentDetail,
        "ChangeTagNamespaceCompartmentDetail",
        models.ChangeTagNamespaceCompartmentDetail.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeTagNamespaceCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new auth token for the specified user. For information about what auth tokens are for, see
* [Managing User Credentials](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcredentials.htm).
* <p>
You must specify a *description* for the auth token (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with
* {@link #updateAuthToken(UpdateAuthTokenRequest) updateAuthToken}.
* <p>
Every user has permission to create an auth token for *their own user ID*. An administrator in your organization
* does not need to write a policy to give users this ability. To compare, administrators who have permission to the
* tenancy can use this operation to create an auth token for any user, including themselves.
* 
     * @param CreateAuthTokenRequest
     * @return CreateAuthTokenResponse
     * @throws OciError when an error occurs
     */
  public async createAuthToken(
    createAuthTokenRequest: requests.CreateAuthTokenRequest
  ): Promise<responses.CreateAuthTokenResponse> {
    const pathParams = {
      "{userId}": createAuthTokenRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createAuthTokenRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/authTokens",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createAuthTokenRequest.createAuthTokenDetails,
        "CreateAuthTokenDetails",
        models.CreateAuthTokenDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateAuthTokenResponse>{},
        body: await response.json(),
        bodyKey: "authToken",
        bodyModel: "model.AuthToken",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new compartment in the specified compartment.
* <p>
**Important:** Compartments cannot be deleted.
* <p>
Specify the parent compartment's OCID as the compartment ID in the request object. Remember that the tenancy
* is simply the root compartment. For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the compartment, which must be unique across all compartments in
* your tenancy. You can use this name or the OCID when writing policies that apply
* to the compartment. For more information about policies, see
* [How Policies Work](https://docs.cloud.oracle.com/Content/Identity/Concepts/policies.htm).
* <p>
You must also specify a *description* for the compartment (although it can be an empty string). It does
* not have to be unique, and you can change it anytime with
* {@link #updateCompartment(UpdateCompartmentRequest) updateCompartment}.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* 
     * @param CreateCompartmentRequest
     * @return CreateCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async createCompartment(
    createCompartmentRequest: requests.CreateCompartmentRequest
  ): Promise<responses.CreateCompartmentResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCompartmentRequest.createCompartmentDetails,
        "CreateCompartmentDetails",
        models.CreateCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCompartmentResponse>{},
        body: await response.json(),
        bodyKey: "compartment",
        bodyModel: "model.Compartment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new secret key for the specified user. Secret keys are used for authentication with the Object Storage Service's Amazon S3
* compatible API. For information, see
* [Managing User Credentials](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcredentials.htm).
* <p>
You must specify a *description* for the secret key (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with
* {@link #updateCustomerSecretKey(UpdateCustomerSecretKeyRequest) updateCustomerSecretKey}.
* <p>
Every user has permission to create a secret key for *their own user ID*. An administrator in your organization
* does not need to write a policy to give users this ability. To compare, administrators who have permission to the
* tenancy can use this operation to create a secret key for any user, including themselves.
* 
     * @param CreateCustomerSecretKeyRequest
     * @return CreateCustomerSecretKeyResponse
     * @throws OciError when an error occurs
     */
  public async createCustomerSecretKey(
    createCustomerSecretKeyRequest: requests.CreateCustomerSecretKeyRequest
  ): Promise<responses.CreateCustomerSecretKeyResponse> {
    const pathParams = {
      "{userId}": createCustomerSecretKeyRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createCustomerSecretKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/customerSecretKeys",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createCustomerSecretKeyRequest.createCustomerSecretKeyDetails,
        "CreateCustomerSecretKeyDetails",
        models.CreateCustomerSecretKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateCustomerSecretKeyResponse>{},
        body: await response.json(),
        bodyKey: "customerSecretKey",
        bodyModel: "model.CustomerSecretKey",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new dynamic group in your tenancy.
* <p>
You must specify your tenancy's OCID as the compartment ID in the request object (remember that the tenancy
* is simply the root compartment). Notice that IAM resources (users, groups, compartments, and some policies)
* reside within the tenancy itself, unlike cloud resources such as compute instances, which typically
* reside within compartments inside the tenancy. For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the dynamic group, which must be unique across all dynamic groups in your
* tenancy, and cannot be changed. Note that this name has to be also unique across all groups in your tenancy.
* You can use this name or the OCID when writing policies that apply to the dynamic group. For more information
* about policies, see [How Policies Work](https://docs.cloud.oracle.com/Content/Identity/Concepts/policies.htm).
* <p>
You must also specify a *description* for the dynamic group (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with {@link #updateDynamicGroup(UpdateDynamicGroupRequest) updateDynamicGroup}.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* 
     * @param CreateDynamicGroupRequest
     * @return CreateDynamicGroupResponse
     * @throws OciError when an error occurs
     */
  public async createDynamicGroup(
    createDynamicGroupRequest: requests.CreateDynamicGroupRequest
  ): Promise<responses.CreateDynamicGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createDynamicGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dynamicGroups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createDynamicGroupRequest.createDynamicGroupDetails,
        "CreateDynamicGroupDetails",
        models.CreateDynamicGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateDynamicGroupResponse>{},
        body: await response.json(),
        bodyKey: "dynamicGroup",
        bodyModel: "model.DynamicGroup",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new group in your tenancy.
* <p>
You must specify your tenancy's OCID as the compartment ID in the request object (remember that the tenancy
* is simply the root compartment). Notice that IAM resources (users, groups, compartments, and some policies)
* reside within the tenancy itself, unlike cloud resources such as compute instances, which typically
* reside within compartments inside the tenancy. For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the group, which must be unique across all groups in your tenancy and
* cannot be changed. You can use this name or the OCID when writing policies that apply to the group. For more
* information about policies, see [How Policies Work](https://docs.cloud.oracle.com/Content/Identity/Concepts/policies.htm).
* <p>
You must also specify a *description* for the group (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with {@link #updateGroup(UpdateGroupRequest) updateGroup}.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* <p>
After creating the group, you need to put users in it and write policies for it.
* See {@link #addUserToGroup(AddUserToGroupRequest) addUserToGroup} and
* {@link #createPolicy(CreatePolicyRequest) createPolicy}.
* 
     * @param CreateGroupRequest
     * @return CreateGroupResponse
     * @throws OciError when an error occurs
     */
  public async createGroup(
    createGroupRequest: requests.CreateGroupRequest
  ): Promise<responses.CreateGroupResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createGroupRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/groups",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createGroupRequest.createGroupDetails,
        "CreateGroupDetails",
        models.CreateGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateGroupResponse>{},
        body: await response.json(),
        bodyKey: "group",
        bodyModel: "model.Group",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new identity provider in your tenancy. For more information, see
* [Identity Providers and Federation](https://docs.cloud.oracle.com/Content/Identity/Concepts/federation.htm).
* <p>
You must specify your tenancy's OCID as the compartment ID in the request object.
* Remember that the tenancy is simply the root compartment. For information about
* OCIDs, see [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the `IdentityProvider`, which must be unique
* across all `IdentityProvider` objects in your tenancy and cannot be changed.
* <p>
You must also specify a *description* for the `IdentityProvider` (although
* it can be an empty string). It does not have to be unique, and you can change
* it anytime with
* {@link #updateIdentityProvider(UpdateIdentityProviderRequest) updateIdentityProvider}.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily
* be CREATING. Before using the object, first make sure its `lifecycleState` has
* changed to ACTIVE.
* 
     * @param CreateIdentityProviderRequest
     * @return CreateIdentityProviderResponse
     * @throws OciError when an error occurs
     */
  public async createIdentityProvider(
    createIdentityProviderRequest: requests.CreateIdentityProviderRequest
  ): Promise<responses.CreateIdentityProviderResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createIdentityProviderRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createIdentityProviderRequest.createIdentityProviderDetails,
        "CreateIdentityProviderDetails",
        models.CreateIdentityProviderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateIdentityProviderResponse>{},
        body: await response.json(),
        bodyKey: "identityProvider",
        bodyModel: "model.IdentityProvider",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a single mapping between an IdP group and an IAM Service
   * {@link Group}.
   *
   * @param CreateIdpGroupMappingRequest
   * @return CreateIdpGroupMappingResponse
   * @throws OciError when an error occurs
   */
  public async createIdpGroupMapping(
    createIdpGroupMappingRequest: requests.CreateIdpGroupMappingRequest
  ): Promise<responses.CreateIdpGroupMappingResponse> {
    const pathParams = {
      "{identityProviderId}": createIdpGroupMappingRequest.identityProviderId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createIdpGroupMappingRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groupMappings",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createIdpGroupMappingRequest.createIdpGroupMappingDetails,
        "CreateIdpGroupMappingDetails",
        models.CreateIdpGroupMappingDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateIdpGroupMappingResponse>{},
        body: await response.json(),
        bodyKey: "idpGroupMapping",
        bodyModel: "model.IdpGroupMapping",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new MFA TOTP device for the user. A user can have one MFA TOTP device.
   *
   * @param CreateMfaTotpDeviceRequest
   * @return CreateMfaTotpDeviceResponse
   * @throws OciError when an error occurs
   */
  public async createMfaTotpDevice(
    createMfaTotpDeviceRequest: requests.CreateMfaTotpDeviceRequest
  ): Promise<responses.CreateMfaTotpDeviceResponse> {
    const pathParams = {
      "{userId}": createMfaTotpDeviceRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createMfaTotpDeviceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateMfaTotpDeviceResponse>{},
        body: await response.json(),
        bodyKey: "mfaTotpDevice",
        bodyModel: "model.MfaTotpDevice",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new network source in your tenancy.
* <p>
You must specify your tenancy's OCID as the compartment ID in the request object (remember that the tenancy
* is simply the root compartment). Notice that IAM resources (users, groups, compartments, and some policies)
* reside within the tenancy itself, unlike cloud resources such as compute instances, which typically
* reside within compartments inside the tenancy. For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the network source, which must be unique across all network sources in your
* tenancy, and cannot be changed.
* You can use this name or the OCID when writing policies that apply to the network source. For more information
* about policies, see [How Policies Work](https://docs.cloud.oracle.com/Content/Identity/Concepts/policies.htm).
* <p>
You must also specify a *description* for the network source (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with {@link #updateNetworkSource(UpdateNetworkSourceRequest) updateNetworkSource}.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* <p>
After your network resource is created, you can use it in policy to restrict access to only requests made from an allowed 
* IP address specified in your network source. For more information, see [Managing Network Sources](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingnetworksources.htm).
* 
     * @param CreateNetworkSourceRequest
     * @return CreateNetworkSourceResponse
     * @throws OciError when an error occurs
     */
  public async createNetworkSource(
    createNetworkSourceRequest: requests.CreateNetworkSourceRequest
  ): Promise<responses.CreateNetworkSourceResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createNetworkSourceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSources",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createNetworkSourceRequest.createNetworkSourceDetails,
        "CreateNetworkSourceDetails",
        models.CreateNetworkSourceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateNetworkSourceResponse>{},
        body: await response.json(),
        bodyKey: "networkSources",
        bodyModel: "model.NetworkSources",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates Oauth token for the user
   *
   * @param CreateOAuthClientCredentialRequest
   * @return CreateOAuthClientCredentialResponse
   * @throws OciError when an error occurs
   */
  public async createOAuthClientCredential(
    createOAuthClientCredentialRequest: requests.CreateOAuthClientCredentialRequest
  ): Promise<responses.CreateOAuthClientCredentialResponse> {
    const pathParams = {
      "{userId}": createOAuthClientCredentialRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createOAuthClientCredentialRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/oauth2ClientCredentials",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createOAuthClientCredentialRequest.createOAuth2ClientCredentialDetails,
        "CreateOAuth2ClientCredentialDetails",
        models.CreateOAuth2ClientCredentialDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateOAuthClientCredentialResponse>{},
        body: await response.json(),
        bodyKey: "oAuth2ClientCredential",
        bodyModel: "model.OAuth2ClientCredential",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new Console one-time password for the specified user. For more information about user
* credentials, see [User Credentials](https://docs.cloud.oracle.com/Content/Identity/Concepts/usercredentials.htm).
* <p>
Use this operation after creating a new user, or if a user forgets their password. The new one-time
* password is returned to you in the response, and you must securely deliver it to the user. They'll
* be prompted to change this password the next time they sign in to the Console. If they don't change
* it within 7 days, the password will expire and you'll need to create a new one-time password for the
* user.
* <p>
**Note:** The user's Console login is the unique name you specified when you created the user
* (see {@link #createUser(CreateUserRequest) createUser}).
* 
     * @param CreateOrResetUIPasswordRequest
     * @return CreateOrResetUIPasswordResponse
     * @throws OciError when an error occurs
     */
  public async createOrResetUIPassword(
    createOrResetUIPasswordRequest: requests.CreateOrResetUIPasswordRequest
  ): Promise<responses.CreateOrResetUIPasswordResponse> {
    const pathParams = {
      "{userId}": createOrResetUIPasswordRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createOrResetUIPasswordRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/uiPassword",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateOrResetUIPasswordResponse>{},
        body: await response.json(),
        bodyKey: "uIPassword",
        bodyModel: "model.UIPassword",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new policy in the specified compartment (either the tenancy or another of your compartments).
* If you're new to policies, see [Getting Started with Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/policygetstarted.htm).
* <p>
You must specify a *name* for the policy, which must be unique across all policies in your tenancy
* and cannot be changed.
* <p>
You must also specify a *description* for the policy (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with {@link #updatePolicy(UpdatePolicyRequest) updatePolicy}.
* <p>
You must specify one or more policy statements in the statements array. For information about writing
* policies, see [How Policies Work](https://docs.cloud.oracle.com/Content/Identity/Concepts/policies.htm) and
* [Common Policies](https://docs.cloud.oracle.com/Content/Identity/Concepts/commonpolicies.htm).
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using the
* object, first make sure its `lifecycleState` has changed to ACTIVE.
* <p>
New policies take effect typically within 10 seconds.
* 
     * @param CreatePolicyRequest
     * @return CreatePolicyResponse
     * @throws OciError when an error occurs
     */
  public async createPolicy(
    createPolicyRequest: requests.CreatePolicyRequest
  ): Promise<responses.CreatePolicyResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createPolicyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/policies",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createPolicyRequest.createPolicyDetails,
        "CreatePolicyDetails",
        models.CreatePolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreatePolicyResponse>{},
        body: await response.json(),
        bodyKey: "policy",
        bodyModel: "model.Policy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a subscription to a region for a tenancy.
   *
   * @param CreateRegionSubscriptionRequest
   * @return CreateRegionSubscriptionResponse
   * @throws OciError when an error occurs
   */
  public async createRegionSubscription(
    createRegionSubscriptionRequest: requests.CreateRegionSubscriptionRequest
  ): Promise<responses.CreateRegionSubscriptionResponse> {
    const pathParams = {
      "{tenancyId}": createRegionSubscriptionRequest.tenancyId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createRegionSubscriptionRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tenancies/{tenancyId}/regionSubscriptions",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createRegionSubscriptionRequest.createRegionSubscriptionDetails,
        "CreateRegionSubscriptionDetails",
        models.CreateRegionSubscriptionDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateRegionSubscriptionResponse>{},
        body: await response.json(),
        bodyKey: "regionSubscription",
        bodyModel: "model.RegionSubscription",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new SMTP credential for the specified user. An SMTP credential has an SMTP user name and an SMTP password.
   * You must specify a *description* for the SMTP credential (although it can be an empty string). It does not
   * have to be unique, and you can change it anytime with
   * {@link #updateSmtpCredential(UpdateSmtpCredentialRequest) updateSmtpCredential}.
   *
   * @param CreateSmtpCredentialRequest
   * @return CreateSmtpCredentialResponse
   * @throws OciError when an error occurs
   */
  public async createSmtpCredential(
    createSmtpCredentialRequest: requests.CreateSmtpCredentialRequest
  ): Promise<responses.CreateSmtpCredentialResponse> {
    const pathParams = {
      "{userId}": createSmtpCredentialRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSmtpCredentialRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/smtpCredentials",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSmtpCredentialRequest.createSmtpCredentialDetails,
        "CreateSmtpCredentialDetails",
        models.CreateSmtpCredentialDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSmtpCredentialResponse>{},
        body: await response.json(),
        bodyKey: "smtpCredential",
        bodyModel: "model.SmtpCredential",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * **Deprecated. Use {@link #createAuthToken(CreateAuthTokenRequest) createAuthToken} instead.**
* <p>
Creates a new Swift password for the specified user. For information about what Swift passwords are for, see
* [Managing User Credentials](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcredentials.htm).
* <p>
You must specify a *description* for the Swift password (although it can be an empty string). It does not
* have to be unique, and you can change it anytime with
* {@link #updateSwiftPassword(UpdateSwiftPasswordRequest) updateSwiftPassword}.
* <p>
Every user has permission to create a Swift password for *their own user ID*. An administrator in your organization
* does not need to write a policy to give users this ability. To compare, administrators who have permission to the
* tenancy can use this operation to create a Swift password for any user, including themselves.
* 
     * @param CreateSwiftPasswordRequest
     * @return CreateSwiftPasswordResponse
     * @throws OciError when an error occurs
     */
  public async createSwiftPassword(
    createSwiftPasswordRequest: requests.CreateSwiftPasswordRequest
  ): Promise<responses.CreateSwiftPasswordResponse> {
    const pathParams = {
      "{userId}": createSwiftPasswordRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSwiftPasswordRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/swiftPasswords",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSwiftPasswordRequest.createSwiftPasswordDetails,
        "CreateSwiftPasswordDetails",
        models.CreateSwiftPasswordDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSwiftPasswordResponse>{},
        body: await response.json(),
        bodyKey: "swiftPassword",
        bodyModel: "model.SwiftPassword",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new tag in the specified tag namespace.
* <p>
The tag requires either the OCID or the name of the tag namespace that will contain this 
* tag definition.
* <p>
You must specify a *name* for the tag, which must be unique across all tags in the tag namespace
* and cannot be changed. The name can contain any ASCII character except the space (_) or period (.) characters.
* Names are case insensitive. That means, for example, \"myTag\" and \"mytag\" are not allowed in the same namespace.
* If you specify a name that's already in use in the tag namespace, a 409 error is returned.
* <p>
The tag must have a *description*. It does not have to be unique, and you can change it with
* {@link #updateTag(UpdateTagRequest) updateTag}.
* <p>
The tag must have a value type, which is specified with a validator. Tags can use either a 
* static value or a list of possible values. Static values are entered by a user applying the tag
* to a resource. Lists are created by you and the user must apply a value from the list. Lists 
* are validiated. 
* <p>
* If no `validator` is set, the user applying the tag to a resource can type in a static 
* value or leave the tag value empty. 
* * If a `validator` is set, the user applying the tag to a resource must select from a list
* of values that you supply with {@link #enumTagDefinitionValidator(EnumTagDefinitionValidatorRequest) enumTagDefinitionValidator}.
* 
     * @param CreateTagRequest
     * @return CreateTagResponse
     * @throws OciError when an error occurs
     */
  public async createTag(
    createTagRequest: requests.CreateTagRequest
  ): Promise<responses.CreateTagResponse> {
    const pathParams = {
      "{tagNamespaceId}": createTagRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTagRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/tags",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTagRequest.createTagDetails,
        "CreateTagDetails",
        models.CreateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTagResponse>{},
        body: await response.json(),
        bodyKey: "tag",
        bodyModel: "model.Tag",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new tag default in the specified compartment for the specified tag definition.
* <p>
If you specify that a value is required, a value is set during resource creation (either by 
* the user creating the resource or another tag defualt). If no value is set, resource creation 
* is blocked.
* <p>
* If the `isRequired` flag is set to \"true\", the value is set during resource creation.
* * If the `isRequired` flag is set to \"false\", the value you enter is set during resource creation.
* 
     * @param CreateTagDefaultRequest
     * @return CreateTagDefaultResponse
     * @throws OciError when an error occurs
     */
  public async createTagDefault(
    createTagDefaultRequest: requests.CreateTagDefaultRequest
  ): Promise<responses.CreateTagDefaultResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTagDefaultRequest.opcRetryToken,
      "opc-request-id": createTagDefaultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTagDefaultRequest.createTagDefaultDetails,
        "CreateTagDefaultDetails",
        models.CreateTagDefaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTagDefaultResponse>{},
        body: await response.json(),
        bodyKey: "tagDefault",
        bodyModel: "model.TagDefault",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new tag namespace in the specified compartment.
* <p>
You must specify the compartment ID in the request object (remember that the tenancy is simply the root
* compartment).
* <p>
You must also specify a *name* for the namespace, which must be unique across all namespaces in your tenancy
* and cannot be changed. The name can contain any ASCII character except the space (_) or period (.).
* Names are case insensitive. That means, for example, \"myNamespace\" and \"mynamespace\" are not allowed
* in the same tenancy. Once you created a namespace, you cannot change the name.
* If you specify a name that's already in use in the tenancy, a 409 error is returned.
* <p>
You must also specify a *description* for the namespace.
* It does not have to be unique, and you can change it with
* {@link #updateTagNamespace(UpdateTagNamespaceRequest) updateTagNamespace}.
* 
     * @param CreateTagNamespaceRequest
     * @return CreateTagNamespaceResponse
     * @throws OciError when an error occurs
     */
  public async createTagNamespace(
    createTagNamespaceRequest: requests.CreateTagNamespaceRequest
  ): Promise<responses.CreateTagNamespaceResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createTagNamespaceRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTagNamespaceRequest.createTagNamespaceDetails,
        "CreateTagNamespaceDetails",
        models.CreateTagNamespaceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTagNamespaceResponse>{},
        body: await response.json(),
        bodyKey: "tagNamespace",
        bodyModel: "model.TagNamespace",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Creates a new user in your tenancy. For conceptual information about users, your tenancy, and other
* IAM Service components, see [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).
* <p>
You must specify your tenancy's OCID as the compartment ID in the request object (remember that the
* tenancy is simply the root compartment). Notice that IAM resources (users, groups, compartments, and
* some policies) reside within the tenancy itself, unlike cloud resources such as compute instances,
* which typically reside within compartments inside the tenancy. For information about OCIDs, see
* [Resource Identifiers](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm).
* <p>
You must also specify a *name* for the user, which must be unique across all users in your tenancy
* and cannot be changed. Allowed characters: No spaces. Only letters, numerals, hyphens, periods,
* underscores, +, and @. If you specify a name that's already in use, you'll get a 409 error.
* This name will be the user's login to the Console. You might want to pick a
* name that your company's own identity system (e.g., Active Directory, LDAP, etc.) already uses.
* If you delete a user and then create a new user with the same name, they'll be considered different
* users because they have different OCIDs.
* <p>
You must also specify a *description* for the user (although it can be an empty string).
* It does not have to be unique, and you can change it anytime with
* {@link #updateUser(UpdateUserRequest) updateUser}. You can use the field to provide the user's
* full name, a description, a nickname, or other information to generally identify the user.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before
* using the object, first make sure its `lifecycleState` has changed to ACTIVE.
* <p>
A new user has no permissions until you place the user in one or more groups (see
* {@link #addUserToGroup(AddUserToGroupRequest) addUserToGroup}). If the user needs to
* access the Console, you need to provide the user a password (see
* {@link #createOrResetUIPassword(CreateOrResetUIPasswordRequest) createOrResetUIPassword}).
* If the user needs to access the Oracle Cloud Infrastructure REST API, you need to upload a
* public API signing key for that user (see
* [Required Keys and OCIDs](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm) and also
* {@link #uploadApiKey(UploadApiKeyRequest) uploadApiKey}).
* <p>
**Important:** Make sure to inform the new user which compartment(s) they have access to.
* 
     * @param CreateUserRequest
     * @return CreateUserResponse
     * @throws OciError when an error occurs
     */
  public async createUser(
    createUserRequest: requests.CreateUserRequest
  ): Promise<responses.CreateUserResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createUserRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createUserRequest.createUserDetails,
        "CreateUserDetails",
        models.CreateUserDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateUserResponse>{},
        body: await response.json(),
        bodyKey: "user",
        bodyModel: "model.User",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified API signing key for the specified user.
* <p>
Every user has permission to use this operation to delete a key for *their own user ID*. An
* administrator in your organization does not need to write a policy to give users this ability.
* To compare, administrators who have permission to the tenancy can use this operation to delete
* a key for any user, including themselves.
* 
     * @param DeleteApiKeyRequest
     * @return DeleteApiKeyResponse
     * @throws OciError when an error occurs
     */
  public async deleteApiKey(
    deleteApiKeyRequest: requests.DeleteApiKeyRequest
  ): Promise<responses.DeleteApiKeyResponse> {
    const pathParams = {
      "{userId}": deleteApiKeyRequest.userId,
      "{fingerprint}": deleteApiKeyRequest.fingerprint
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteApiKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/apiKeys/{fingerprint}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteApiKeyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified auth token for the specified user.
   *
   * @param DeleteAuthTokenRequest
   * @return DeleteAuthTokenResponse
   * @throws OciError when an error occurs
   */
  public async deleteAuthToken(
    deleteAuthTokenRequest: requests.DeleteAuthTokenRequest
  ): Promise<responses.DeleteAuthTokenResponse> {
    const pathParams = {
      "{userId}": deleteAuthTokenRequest.userId,
      "{authTokenId}": deleteAuthTokenRequest.authTokenId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteAuthTokenRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/authTokens/{authTokenId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteAuthTokenResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified compartment. The compartment must be empty.
   *
   * @param DeleteCompartmentRequest
   * @return DeleteCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async deleteCompartment(
    deleteCompartmentRequest: requests.DeleteCompartmentRequest
  ): Promise<responses.DeleteCompartmentResponse> {
    const pathParams = {
      "{compartmentId}": deleteCompartmentRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified secret key for the specified user.
   *
   * @param DeleteCustomerSecretKeyRequest
   * @return DeleteCustomerSecretKeyResponse
   * @throws OciError when an error occurs
   */
  public async deleteCustomerSecretKey(
    deleteCustomerSecretKeyRequest: requests.DeleteCustomerSecretKeyRequest
  ): Promise<responses.DeleteCustomerSecretKeyResponse> {
    const pathParams = {
      "{userId}": deleteCustomerSecretKeyRequest.userId,
      "{customerSecretKeyId}": deleteCustomerSecretKeyRequest.customerSecretKeyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteCustomerSecretKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/customerSecretKeys/{customerSecretKeyId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteCustomerSecretKeyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified dynamic group.
   *
   * @param DeleteDynamicGroupRequest
   * @return DeleteDynamicGroupResponse
   * @throws OciError when an error occurs
   */
  public async deleteDynamicGroup(
    deleteDynamicGroupRequest: requests.DeleteDynamicGroupRequest
  ): Promise<responses.DeleteDynamicGroupResponse> {
    const pathParams = {
      "{dynamicGroupId}": deleteDynamicGroupRequest.dynamicGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteDynamicGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dynamicGroups/{dynamicGroupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDynamicGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified group. The group must be empty.
   *
   * @param DeleteGroupRequest
   * @return DeleteGroupResponse
   * @throws OciError when an error occurs
   */
  public async deleteGroup(
    deleteGroupRequest: requests.DeleteGroupRequest
  ): Promise<responses.DeleteGroupResponse> {
    const pathParams = {
      "{groupId}": deleteGroupRequest.groupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/groups/{groupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified identity provider. The identity provider must not have
   * any group mappings (see {@link IdpGroupMapping}).
   *
   * @param DeleteIdentityProviderRequest
   * @return DeleteIdentityProviderResponse
   * @throws OciError when an error occurs
   */
  public async deleteIdentityProvider(
    deleteIdentityProviderRequest: requests.DeleteIdentityProviderRequest
  ): Promise<responses.DeleteIdentityProviderResponse> {
    const pathParams = {
      "{identityProviderId}": deleteIdentityProviderRequest.identityProviderId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteIdentityProviderRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteIdentityProviderResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified group mapping.
   * @param DeleteIdpGroupMappingRequest
   * @return DeleteIdpGroupMappingResponse
   * @throws OciError when an error occurs
   */
  public async deleteIdpGroupMapping(
    deleteIdpGroupMappingRequest: requests.DeleteIdpGroupMappingRequest
  ): Promise<responses.DeleteIdpGroupMappingResponse> {
    const pathParams = {
      "{identityProviderId}": deleteIdpGroupMappingRequest.identityProviderId,
      "{mappingId}": deleteIdpGroupMappingRequest.mappingId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteIdpGroupMappingRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteIdpGroupMappingResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified MFA TOTP device for the specified user.
   *
   * @param DeleteMfaTotpDeviceRequest
   * @return DeleteMfaTotpDeviceResponse
   * @throws OciError when an error occurs
   */
  public async deleteMfaTotpDevice(
    deleteMfaTotpDeviceRequest: requests.DeleteMfaTotpDeviceRequest
  ): Promise<responses.DeleteMfaTotpDeviceResponse> {
    const pathParams = {
      "{userId}": deleteMfaTotpDeviceRequest.userId,
      "{mfaTotpDeviceId}": deleteMfaTotpDeviceRequest.mfaTotpDeviceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteMfaTotpDeviceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices/{mfaTotpDeviceId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteMfaTotpDeviceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified network source
   *
   * @param DeleteNetworkSourceRequest
   * @return DeleteNetworkSourceResponse
   * @throws OciError when an error occurs
   */
  public async deleteNetworkSource(
    deleteNetworkSourceRequest: requests.DeleteNetworkSourceRequest
  ): Promise<responses.DeleteNetworkSourceResponse> {
    const pathParams = {
      "{networkSourceId}": deleteNetworkSourceRequest.networkSourceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteNetworkSourceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSources/{networkSourceId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteNetworkSourceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Delete Oauth token for the user
   *
   * @param DeleteOAuthClientCredentialRequest
   * @return DeleteOAuthClientCredentialResponse
   * @throws OciError when an error occurs
   */
  public async deleteOAuthClientCredential(
    deleteOAuthClientCredentialRequest: requests.DeleteOAuthClientCredentialRequest
  ): Promise<responses.DeleteOAuthClientCredentialResponse> {
    const pathParams = {
      "{userId}": deleteOAuthClientCredentialRequest.userId,
      "{oauth2ClientCredentialId}": deleteOAuthClientCredentialRequest.oauth2ClientCredentialId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteOAuthClientCredentialRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/oauth2ClientCredentials/{oauth2ClientCredentialId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteOAuthClientCredentialResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified policy. The deletion takes effect typically within 10 seconds.
   * @param DeletePolicyRequest
   * @return DeletePolicyResponse
   * @throws OciError when an error occurs
   */
  public async deletePolicy(
    deletePolicyRequest: requests.DeletePolicyRequest
  ): Promise<responses.DeletePolicyResponse> {
    const pathParams = {
      "{policyId}": deletePolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deletePolicyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/policies/{policyId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeletePolicyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified SMTP credential for the specified user.
   *
   * @param DeleteSmtpCredentialRequest
   * @return DeleteSmtpCredentialResponse
   * @throws OciError when an error occurs
   */
  public async deleteSmtpCredential(
    deleteSmtpCredentialRequest: requests.DeleteSmtpCredentialRequest
  ): Promise<responses.DeleteSmtpCredentialResponse> {
    const pathParams = {
      "{userId}": deleteSmtpCredentialRequest.userId,
      "{smtpCredentialId}": deleteSmtpCredentialRequest.smtpCredentialId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteSmtpCredentialRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/smtpCredentials/{smtpCredentialId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSmtpCredentialResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * **Deprecated. Use {@link #deleteAuthToken(DeleteAuthTokenRequest) deleteAuthToken} instead.**
* <p>
Deletes the specified Swift password for the specified user.
* 
     * @param DeleteSwiftPasswordRequest
     * @return DeleteSwiftPasswordResponse
     * @throws OciError when an error occurs
     */
  public async deleteSwiftPassword(
    deleteSwiftPasswordRequest: requests.DeleteSwiftPasswordRequest
  ): Promise<responses.DeleteSwiftPasswordResponse> {
    const pathParams = {
      "{userId}": deleteSwiftPasswordRequest.userId,
      "{swiftPasswordId}": deleteSwiftPasswordRequest.swiftPasswordId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteSwiftPasswordRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/swiftPasswords/{swiftPasswordId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSwiftPasswordResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified tag definition. This operation triggers a process that removes the
* tag from all resources in your tenancy. 
* <p>
These things happen immediately:
* \u00A0
*   * If the tag was a cost-tracking tag, it no longer counts against your 10 cost-tracking 
*   tags limit, whether you first disabled it or not.
*   * If the tag was used with dynamic groups, none of the rules that contain the tag will 
*   be evaluated against the tag. 
* <p>
When you start the delete operation, the state of the tag changes to DELETING and tag removal
* from resources begins. This can take up to 48 hours depending on the number of resources that
* were tagged as well as the regions in which those resources reside.
* <p>
When all tags have been removed, the state changes to DELETED. You cannot restore a deleted tag. Once the deleted tag
* changes its state to DELETED, you can use the same tag name again.
* <p>
After you start this operation, you cannot start either the {@link #bulkDeleteTags(BulkDeleteTagsRequest) bulkDeleteTags} or the {@link #cascadeDeleteTagNamespace(CascadeDeleteTagNamespaceRequest) cascadeDeleteTagNamespace} operation until this process completes. 
* <p>
To delete a tag, you must first retire it. Use {@link #updateTag(UpdateTagRequest) updateTag}
* to retire a tag. 
* 
     * @param DeleteTagRequest
     * @return DeleteTagResponse
     * @throws OciError when an error occurs
     */
  public async deleteTag(
    deleteTagRequest: requests.DeleteTagRequest
  ): Promise<responses.DeleteTagResponse> {
    const pathParams = {
      "{tagNamespaceId}": deleteTagRequest.tagNamespaceId,
      "{tagName}": deleteTagRequest.tagName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTagRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/tags/{tagName}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTagResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the the specified tag default.
   *
   * @param DeleteTagDefaultRequest
   * @return DeleteTagDefaultResponse
   * @throws OciError when an error occurs
   */
  public async deleteTagDefault(
    deleteTagDefaultRequest: requests.DeleteTagDefaultRequest
  ): Promise<responses.DeleteTagDefaultResponse> {
    const pathParams = {
      "{tagDefaultId}": deleteTagDefaultRequest.tagDefaultId
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": deleteTagDefaultRequest.opcRequestId,
      "if-match": deleteTagDefaultRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults/{tagDefaultId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTagDefaultResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Deletes the specified tag namespace. Only an empty tag namespace can be deleted with this operation. To use this operation 
* to delete a tag namespace that contains tag definitions, first delete all of its tag definitions. 
* <p>
Use {@link #cascadeDeleteTagNamespace(CascadeDeleteTagNamespaceRequest) cascadeDeleteTagNamespace} to delete a tag namespace along with all of
* the tag definitions contained within that namespace. 
* <p>
Use {@link #deleteTag(DeleteTagRequest) deleteTag} to delete a tag definition.
* 
     * @param DeleteTagNamespaceRequest
     * @return DeleteTagNamespaceResponse
     * @throws OciError when an error occurs
     */
  public async deleteTagNamespace(
    deleteTagNamespaceRequest: requests.DeleteTagNamespaceRequest
  ): Promise<responses.DeleteTagNamespaceResponse> {
    const pathParams = {
      "{tagNamespaceId}": deleteTagNamespaceRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteTagNamespaceRequest.ifMatch,
      "opc-request-id": deleteTagNamespaceRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTagNamespaceResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Deletes the specified user. The user must not be in any groups.
   * @param DeleteUserRequest
   * @return DeleteUserResponse
   * @throws OciError when an error occurs
   */
  public async deleteUser(
    deleteUserRequest: requests.DeleteUserRequest
  ): Promise<responses.DeleteUserResponse> {
    const pathParams = {
      "{userId}": deleteUserRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": deleteUserRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteUserResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Generate seed for the MFA TOTP device.
   *
   * @param GenerateTotpSeedRequest
   * @return GenerateTotpSeedResponse
   * @throws OciError when an error occurs
   */
  public async generateTotpSeed(
    generateTotpSeedRequest: requests.GenerateTotpSeedRequest
  ): Promise<responses.GenerateTotpSeedResponse> {
    const pathParams = {
      "{userId}": generateTotpSeedRequest.userId,
      "{mfaTotpDeviceId}": generateTotpSeedRequest.mfaTotpDeviceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": generateTotpSeedRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices/{mfaTotpDeviceId}/actions/generateSeed",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GenerateTotpSeedResponse>{},
        body: await response.json(),
        bodyKey: "mfaTotpDevice",
        bodyModel: "model.MfaTotpDevice",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the authentication policy for the given tenancy. You must specify your tenant\u2019s OCID as the value for
   * the compartment ID (remember that the tenancy is simply the root compartment).
   *
   * @param GetAuthenticationPolicyRequest
   * @return GetAuthenticationPolicyResponse
   * @throws OciError when an error occurs
   */
  public async getAuthenticationPolicy(
    getAuthenticationPolicyRequest: requests.GetAuthenticationPolicyRequest
  ): Promise<responses.GetAuthenticationPolicyResponse> {
    const pathParams = {
      "{compartmentId}": getAuthenticationPolicyRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/authenticationPolicies/{compartmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetAuthenticationPolicyResponse>{},
        body: await response.json(),
        bodyKey: "authenticationPolicy",
        bodyModel: "model.AuthenticationPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified compartment's information.
* <p>
This operation does not return a list of all the resources inside the compartment. There is no single
* API operation that does that. Compartments can contain multiple types of resources (instances, block
* storage volumes, etc.). To find out what's in a compartment, you must call the \"List\" operation for
* each resource type and specify the compartment's OCID as a query parameter in the request. For example,
* call the {@link #listInstances(ListInstancesRequest) listInstances} operation in the Cloud Compute
* Service or the {@link #listVolumes(ListVolumesRequest) listVolumes} operation in Cloud Block Storage.
* 
     * @param GetCompartmentRequest
     * @return GetCompartmentResponse
     * @throws OciError when an error occurs
     */
  public async getCompartment(
    getCompartmentRequest: requests.GetCompartmentRequest
  ): Promise<responses.GetCompartmentResponse> {
    const pathParams = {
      "{compartmentId}": getCompartmentRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetCompartmentResponse>{},
        body: await response.json(),
        bodyKey: "compartment",
        bodyModel: "model.Compartment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified dynamic group's information.
   *
   * @param GetDynamicGroupRequest
   * @return GetDynamicGroupResponse
   * @throws OciError when an error occurs
   */
  public async getDynamicGroup(
    getDynamicGroupRequest: requests.GetDynamicGroupRequest
  ): Promise<responses.GetDynamicGroupResponse> {
    const pathParams = {
      "{dynamicGroupId}": getDynamicGroupRequest.dynamicGroupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dynamicGroups/{dynamicGroupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDynamicGroupResponse>{},
        body: await response.json(),
        bodyKey: "dynamicGroup",
        bodyModel: "model.DynamicGroup",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Gets the specified group's information.
* <p>
This operation does not return a list of all the users in the group. To do that, use
* {@link #listUserGroupMemberships(ListUserGroupMembershipsRequest) listUserGroupMemberships} and
* provide the group's OCID as a query parameter in the request.
* 
     * @param GetGroupRequest
     * @return GetGroupResponse
     * @throws OciError when an error occurs
     */
  public async getGroup(
    getGroupRequest: requests.GetGroupRequest
  ): Promise<responses.GetGroupResponse> {
    const pathParams = {
      "{groupId}": getGroupRequest.groupId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/groups/{groupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetGroupResponse>{},
        body: await response.json(),
        bodyKey: "group",
        bodyModel: "model.Group",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified identity provider's information.
   * @param GetIdentityProviderRequest
   * @return GetIdentityProviderResponse
   * @throws OciError when an error occurs
   */
  public async getIdentityProvider(
    getIdentityProviderRequest: requests.GetIdentityProviderRequest
  ): Promise<responses.GetIdentityProviderResponse> {
    const pathParams = {
      "{identityProviderId}": getIdentityProviderRequest.identityProviderId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIdentityProviderResponse>{},
        body: await response.json(),
        bodyKey: "identityProvider",
        bodyModel: "model.IdentityProvider",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified group mapping.
   * @param GetIdpGroupMappingRequest
   * @return GetIdpGroupMappingResponse
   * @throws OciError when an error occurs
   */
  public async getIdpGroupMapping(
    getIdpGroupMappingRequest: requests.GetIdpGroupMappingRequest
  ): Promise<responses.GetIdpGroupMappingResponse> {
    const pathParams = {
      "{identityProviderId}": getIdpGroupMappingRequest.identityProviderId,
      "{mappingId}": getIdpGroupMappingRequest.mappingId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIdpGroupMappingResponse>{},
        body: await response.json(),
        bodyKey: "idpGroupMapping",
        bodyModel: "model.IdpGroupMapping",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get the specified MFA TOTP device for the specified user.
   *
   * @param GetMfaTotpDeviceRequest
   * @return GetMfaTotpDeviceResponse
   * @throws OciError when an error occurs
   */
  public async getMfaTotpDevice(
    getMfaTotpDeviceRequest: requests.GetMfaTotpDeviceRequest
  ): Promise<responses.GetMfaTotpDeviceResponse> {
    const pathParams = {
      "{userId}": getMfaTotpDeviceRequest.userId,
      "{mfaTotpDeviceId}": getMfaTotpDeviceRequest.mfaTotpDeviceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices/{mfaTotpDeviceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetMfaTotpDeviceResponse>{},
        body: await response.json(),
        bodyKey: "mfaTotpDeviceSummary",
        bodyModel: "model.MfaTotpDeviceSummary",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified network source's information.
   *
   * @param GetNetworkSourceRequest
   * @return GetNetworkSourceResponse
   * @throws OciError when an error occurs
   */
  public async getNetworkSource(
    getNetworkSourceRequest: requests.GetNetworkSourceRequest
  ): Promise<responses.GetNetworkSourceResponse> {
    const pathParams = {
      "{networkSourceId}": getNetworkSourceRequest.networkSourceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSources/{networkSourceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetNetworkSourceResponse>{},
        body: await response.json(),
        bodyKey: "networkSources",
        bodyModel: "model.NetworkSources",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified policy's information.
   * @param GetPolicyRequest
   * @return GetPolicyResponse
   * @throws OciError when an error occurs
   */
  public async getPolicy(
    getPolicyRequest: requests.GetPolicyRequest
  ): Promise<responses.GetPolicyResponse> {
    const pathParams = {
      "{policyId}": getPolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/policies/{policyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetPolicyResponse>{},
        body: await response.json(),
        bodyKey: "policy",
        bodyModel: "model.Policy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified tag's information.
   * @param GetTagRequest
   * @return GetTagResponse
   * @throws OciError when an error occurs
   */
  public async getTag(getTagRequest: requests.GetTagRequest): Promise<responses.GetTagResponse> {
    const pathParams = {
      "{tagNamespaceId}": getTagRequest.tagNamespaceId,
      "{tagName}": getTagRequest.tagName
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/tags/{tagName}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTagResponse>{},
        body: await response.json(),
        bodyKey: "tag",
        bodyModel: "model.Tag",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Retrieves the specified tag default.
   *
   * @param GetTagDefaultRequest
   * @return GetTagDefaultResponse
   * @throws OciError when an error occurs
   */
  public async getTagDefault(
    getTagDefaultRequest: requests.GetTagDefaultRequest
  ): Promise<responses.GetTagDefaultResponse> {
    const pathParams = {
      "{tagDefaultId}": getTagDefaultRequest.tagDefaultId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults/{tagDefaultId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTagDefaultResponse>{},
        body: await response.json(),
        bodyKey: "tagDefault",
        bodyModel: "model.TagDefault",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified tag namespace's information.
   *
   * @param GetTagNamespaceRequest
   * @return GetTagNamespaceResponse
   * @throws OciError when an error occurs
   */
  public async getTagNamespace(
    getTagNamespaceRequest: requests.GetTagNamespaceRequest
  ): Promise<responses.GetTagNamespaceResponse> {
    const pathParams = {
      "{tagNamespaceId}": getTagNamespaceRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTagNamespaceResponse>{},
        body: await response.json(),
        bodyKey: "tagNamespace",
        bodyModel: "model.TagNamespace",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets details on a specified work request. The workRequestID is returned in the opc-workrequest-id header
   * for any asynchronous operation in the Identity and Access Management service.
   *
   * @param GetTaggingWorkRequestRequest
   * @return GetTaggingWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getTaggingWorkRequest(
    getTaggingWorkRequestRequest: requests.GetTaggingWorkRequestRequest
  ): Promise<responses.GetTaggingWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": getTaggingWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/taggingWorkRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTaggingWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "taggingWorkRequest",
        bodyModel: "model.TaggingWorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Get the specified tenancy's information.
   * @param GetTenancyRequest
   * @return GetTenancyResponse
   * @throws OciError when an error occurs
   */
  public async getTenancy(
    getTenancyRequest: requests.GetTenancyRequest
  ): Promise<responses.GetTenancyResponse> {
    const pathParams = {
      "{tenancyId}": getTenancyRequest.tenancyId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tenancies/{tenancyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTenancyResponse>{},
        body: await response.json(),
        bodyKey: "tenancy",
        bodyModel: "model.Tenancy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified user's information.
   * @param GetUserRequest
   * @return GetUserResponse
   * @throws OciError when an error occurs
   */
  public async getUser(
    getUserRequest: requests.GetUserRequest
  ): Promise<responses.GetUserResponse> {
    const pathParams = {
      "{userId}": getUserRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUserResponse>{},
        body: await response.json(),
        bodyKey: "user",
        bodyModel: "model.User",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified UserGroupMembership's information.
   * @param GetUserGroupMembershipRequest
   * @return GetUserGroupMembershipResponse
   * @throws OciError when an error occurs
   */
  public async getUserGroupMembership(
    getUserGroupMembershipRequest: requests.GetUserGroupMembershipRequest
  ): Promise<responses.GetUserGroupMembershipResponse> {
    const pathParams = {
      "{userGroupMembershipId}": getUserGroupMembershipRequest.userGroupMembershipId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/userGroupMemberships/{userGroupMembershipId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUserGroupMembershipResponse>{},
        body: await response.json(),
        bodyKey: "userGroupMembership",
        bodyModel: "model.UserGroupMembership",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets the specified user's console password information. The returned object contains the user's OCID,
   * but not the password itself. The actual password is returned only when created or reset.
   *
   * @param GetUserUIPasswordInformationRequest
   * @return GetUserUIPasswordInformationResponse
   * @throws OciError when an error occurs
   */
  public async getUserUIPasswordInformation(
    getUserUIPasswordInformationRequest: requests.GetUserUIPasswordInformationRequest
  ): Promise<responses.GetUserUIPasswordInformationResponse> {
    const pathParams = {
      "{userId}": getUserUIPasswordInformationRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/uiPassword",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetUserUIPasswordInformationResponse>{},
        body: await response.json(),
        bodyKey: "uIPasswordInformation",
        bodyModel: "model.UIPasswordInformation",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Gets details on a specified work request. The workRequestID is returned in the opc-workrequest-id header
   * for any asynchronous operation in the Identity and Access Management service.
   *
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the API signing keys for the specified user. A user can have a maximum of three keys.
* <p>
Every user has permission to use this API call for *their own user ID*.  An administrator in your
* organization does not need to write a policy to give users this ability.
* 
     * @param ListApiKeysRequest
     * @return ListApiKeysResponse
     * @throws OciError when an error occurs
     */
  public async listApiKeys(
    listApiKeysRequest: requests.ListApiKeysRequest
  ): Promise<responses.ListApiKeysResponse> {
    const pathParams = {
      "{userId}": listApiKeysRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/apiKeys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListApiKeysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ApiKey[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the auth tokens for the specified user. The returned object contains the token's OCID, but not
   * the token itself. The actual token is returned only upon creation.
   *
   * @param ListAuthTokensRequest
   * @return ListAuthTokensResponse
   * @throws OciError when an error occurs
   */
  public async listAuthTokens(
    listAuthTokensRequest: requests.ListAuthTokensRequest
  ): Promise<responses.ListAuthTokensResponse> {
    const pathParams = {
      "{userId}": listAuthTokensRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/authTokens",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAuthTokensResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AuthToken[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the availability domains in your tenancy. Specify the OCID of either the tenancy or another
   * of your compartments as the value for the compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   * Note that the order of the results returned can change if availability domains are added or removed; therefore, do not
   * create a dependency on the list order.
   *
   * @param ListAvailabilityDomainsRequest
   * @return ListAvailabilityDomainsResponse
   * @throws OciError when an error occurs
   */
  public async listAvailabilityDomains(
    listAvailabilityDomainsRequest: requests.ListAvailabilityDomainsRequest
  ): Promise<responses.ListAvailabilityDomainsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listAvailabilityDomainsRequest.compartmentId
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/availabilityDomains",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListAvailabilityDomainsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "AvailabilityDomain[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the resource types supported by compartment bulk actions.
   *
   * @param ListBulkActionResourceTypesRequest
   * @return ListBulkActionResourceTypesResponse
   * @throws OciError when an error occurs
   */
  public async listBulkActionResourceTypes(
    listBulkActionResourceTypesRequest: requests.ListBulkActionResourceTypesRequest
  ): Promise<responses.ListBulkActionResourceTypesResponse> {
    const pathParams = {};

    const queryParams = {
      "bulkActionType": listBulkActionResourceTypesRequest.bulkActionType,
      "page": listBulkActionResourceTypesRequest.page,
      "limit": listBulkActionResourceTypesRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/bulkActionResourceTypes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListBulkActionResourceTypesResponse>{},
        body: await response.json(),
        bodyKey: "bulkActionResourceTypeCollection",
        bodyModel: "model.BulkActionResourceTypeCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Lists the compartments in a specified compartment. The members of the list
* returned depends on the values set for several parameters.
* <p>
With the exception of the tenancy (root compartment), the ListCompartments operation
* returns only the first-level child compartments in the parent compartment specified in
* `compartmentId`. The list does not include any subcompartments of the child
* compartments (grandchildren).
* <p>
The parameter `accessLevel` specifies whether to return only those compartments for which the
* requestor has INSPECT permissions on at least one resource directly
* or indirectly (the resource can be in a subcompartment).
* <p>
The parameter `compartmentIdInSubtree` applies only when you perform ListCompartments on the
* tenancy (root compartment). When set to true, the entire hierarchy of compartments can be returned.
* To get a full list of all compartments and subcompartments in the tenancy (root compartment),
* set the parameter `compartmentIdInSubtree` to true and `accessLevel` to ANY.
* <p>
See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
* 
     * @param ListCompartmentsRequest
     * @return ListCompartmentsResponse
     * @throws OciError when an error occurs
     */
  public async listCompartments(
    listCompartmentsRequest: requests.ListCompartmentsRequest
  ): Promise<responses.ListCompartmentsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCompartmentsRequest.compartmentId,
      "page": listCompartmentsRequest.page,
      "limit": listCompartmentsRequest.limit,
      "accessLevel": listCompartmentsRequest.accessLevel,
      "compartmentIdInSubtree": listCompartmentsRequest.compartmentIdInSubtree
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCompartmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Compartment[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Compartment objects
   * contained in responses from the listCompartments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCompartments(
    request: requests.ListCompartmentsRequest
  ): AsyncIterableIterator<models.Compartment> {
    return paginateRecords(request, req => this.listCompartments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCompartments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCompartmentsResponses(
    request: requests.ListCompartmentsRequest
  ): AsyncIterableIterator<responses.ListCompartmentsResponse> {
    return paginateResponses(request, req => this.listCompartments(req));
  }

  /**
   * Lists all the tags enabled for cost-tracking in the specified tenancy. For information about
   * cost-tracking tags, see [Using Cost-tracking Tags](https://docs.cloud.oracle.com/Content/Identity/Concepts/taggingoverview.htm#costs).
   *
   * @param ListCostTrackingTagsRequest
   * @return ListCostTrackingTagsResponse
   * @throws OciError when an error occurs
   */
  public async listCostTrackingTags(
    listCostTrackingTagsRequest: requests.ListCostTrackingTagsRequest
  ): Promise<responses.ListCostTrackingTagsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listCostTrackingTagsRequest.compartmentId,
      "page": listCostTrackingTagsRequest.page,
      "limit": listCostTrackingTagsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/actions/listCostTrackingTags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCostTrackingTagsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Tag[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Tag objects
   * contained in responses from the listCostTrackingTags operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCostTrackingTags(
    request: requests.ListCostTrackingTagsRequest
  ): AsyncIterableIterator<models.Tag> {
    return paginateRecords(request, req => this.listCostTrackingTags(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listCostTrackingTags operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllCostTrackingTagsResponses(
    request: requests.ListCostTrackingTagsRequest
  ): AsyncIterableIterator<responses.ListCostTrackingTagsResponse> {
    return paginateResponses(request, req => this.listCostTrackingTags(req));
  }

  /**
   * Lists the secret keys for the specified user. The returned object contains the secret key's OCID, but not
   * the secret key itself. The actual secret key is returned only upon creation.
   *
   * @param ListCustomerSecretKeysRequest
   * @return ListCustomerSecretKeysResponse
   * @throws OciError when an error occurs
   */
  public async listCustomerSecretKeys(
    listCustomerSecretKeysRequest: requests.ListCustomerSecretKeysRequest
  ): Promise<responses.ListCustomerSecretKeysResponse> {
    const pathParams = {
      "{userId}": listCustomerSecretKeysRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/customerSecretKeys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListCustomerSecretKeysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "CustomerSecretKeySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the dynamic groups in your tenancy. You must specify your tenancy's OCID as the value for
   * the compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListDynamicGroupsRequest
   * @return ListDynamicGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listDynamicGroups(
    listDynamicGroupsRequest: requests.ListDynamicGroupsRequest
  ): Promise<responses.ListDynamicGroupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listDynamicGroupsRequest.compartmentId,
      "page": listDynamicGroupsRequest.page,
      "limit": listDynamicGroupsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dynamicGroups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListDynamicGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "DynamicGroup[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.DynamicGroup objects
   * contained in responses from the listDynamicGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDynamicGroups(
    request: requests.ListDynamicGroupsRequest
  ): AsyncIterableIterator<models.DynamicGroup> {
    return paginateRecords(request, req => this.listDynamicGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listDynamicGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllDynamicGroupsResponses(
    request: requests.ListDynamicGroupsRequest
  ): AsyncIterableIterator<responses.ListDynamicGroupsResponse> {
    return paginateResponses(request, req => this.listDynamicGroups(req));
  }

  /**
   * Lists the Fault Domains in your tenancy. Specify the OCID of either the tenancy or another
   * of your compartments as the value for the compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListFaultDomainsRequest
   * @return ListFaultDomainsResponse
   * @throws OciError when an error occurs
   */
  public async listFaultDomains(
    listFaultDomainsRequest: requests.ListFaultDomainsRequest
  ): Promise<responses.ListFaultDomainsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listFaultDomainsRequest.compartmentId,
      "availabilityDomain": listFaultDomainsRequest.availabilityDomain
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/faultDomains",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListFaultDomainsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "FaultDomain[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the groups in your tenancy. You must specify your tenancy's OCID as the value for
   * the compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListGroupsRequest
   * @return ListGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listGroups(
    listGroupsRequest: requests.ListGroupsRequest
  ): Promise<responses.ListGroupsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listGroupsRequest.compartmentId,
      "page": listGroupsRequest.page,
      "limit": listGroupsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/groups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Group[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Group objects
   * contained in responses from the listGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllGroups(request: requests.ListGroupsRequest): AsyncIterableIterator<models.Group> {
    return paginateRecords(request, req => this.listGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllGroupsResponses(
    request: requests.ListGroupsRequest
  ): AsyncIterableIterator<responses.ListGroupsResponse> {
    return paginateResponses(request, req => this.listGroups(req));
  }

  /**
   * Lists the identity provider groups.
   * @param ListIdentityProviderGroupsRequest
   * @return ListIdentityProviderGroupsResponse
   * @throws OciError when an error occurs
   */
  public async listIdentityProviderGroups(
    listIdentityProviderGroupsRequest: requests.ListIdentityProviderGroupsRequest
  ): Promise<responses.ListIdentityProviderGroupsResponse> {
    const pathParams = {
      "{identityProviderId}": listIdentityProviderGroupsRequest.identityProviderId
    };

    const queryParams = {
      "page": listIdentityProviderGroupsRequest.page,
      "limit": listIdentityProviderGroupsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIdentityProviderGroupsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IdentityProviderGroupSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IdentityProviderGroupSummary objects
   * contained in responses from the listIdentityProviderGroups operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdentityProviderGroups(
    request: requests.ListIdentityProviderGroupsRequest
  ): AsyncIterableIterator<models.IdentityProviderGroupSummary> {
    return paginateRecords(request, req => this.listIdentityProviderGroups(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIdentityProviderGroups operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdentityProviderGroupsResponses(
    request: requests.ListIdentityProviderGroupsRequest
  ): AsyncIterableIterator<responses.ListIdentityProviderGroupsResponse> {
    return paginateResponses(request, req => this.listIdentityProviderGroups(req));
  }

  /**
   * Lists all the identity providers in your tenancy. You must specify the identity provider type (e.g., `SAML2` for
   * identity providers using the SAML2.0 protocol). You must specify your tenancy's OCID as the value for the
   * compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListIdentityProvidersRequest
   * @return ListIdentityProvidersResponse
   * @throws OciError when an error occurs
   */
  public async listIdentityProviders(
    listIdentityProvidersRequest: requests.ListIdentityProvidersRequest
  ): Promise<responses.ListIdentityProvidersResponse> {
    const pathParams = {};

    const queryParams = {
      "protocol": listIdentityProvidersRequest.protocol,
      "compartmentId": listIdentityProvidersRequest.compartmentId,
      "page": listIdentityProvidersRequest.page,
      "limit": listIdentityProvidersRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIdentityProvidersResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IdentityProvider[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IdentityProvider objects
   * contained in responses from the listIdentityProviders operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdentityProviders(
    request: requests.ListIdentityProvidersRequest
  ): AsyncIterableIterator<models.IdentityProvider> {
    return paginateRecords(request, req => this.listIdentityProviders(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIdentityProviders operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdentityProvidersResponses(
    request: requests.ListIdentityProvidersRequest
  ): AsyncIterableIterator<responses.ListIdentityProvidersResponse> {
    return paginateResponses(request, req => this.listIdentityProviders(req));
  }

  /**
   * Lists the group mappings for the specified identity provider.
   *
   * @param ListIdpGroupMappingsRequest
   * @return ListIdpGroupMappingsResponse
   * @throws OciError when an error occurs
   */
  public async listIdpGroupMappings(
    listIdpGroupMappingsRequest: requests.ListIdpGroupMappingsRequest
  ): Promise<responses.ListIdpGroupMappingsResponse> {
    const pathParams = {
      "{identityProviderId}": listIdpGroupMappingsRequest.identityProviderId
    };

    const queryParams = {
      "page": listIdpGroupMappingsRequest.page,
      "limit": listIdpGroupMappingsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groupMappings",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIdpGroupMappingsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IdpGroupMapping[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IdpGroupMapping objects
   * contained in responses from the listIdpGroupMappings operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdpGroupMappings(
    request: requests.ListIdpGroupMappingsRequest
  ): AsyncIterableIterator<models.IdpGroupMapping> {
    return paginateRecords(request, req => this.listIdpGroupMappings(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIdpGroupMappings operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIdpGroupMappingsResponses(
    request: requests.ListIdpGroupMappingsRequest
  ): AsyncIterableIterator<responses.ListIdpGroupMappingsResponse> {
    return paginateResponses(request, req => this.listIdpGroupMappings(req));
  }

  /**
   * Lists the MFA TOTP devices for the specified user. The returned object contains the device's OCID, but not
   * the seed. The seed is returned only upon creation or when the IAM service regenerates the MFA seed for the device.
   *
   * @param ListMfaTotpDevicesRequest
   * @return ListMfaTotpDevicesResponse
   * @throws OciError when an error occurs
   */
  public async listMfaTotpDevices(
    listMfaTotpDevicesRequest: requests.ListMfaTotpDevicesRequest
  ): Promise<responses.ListMfaTotpDevicesResponse> {
    const pathParams = {
      "{userId}": listMfaTotpDevicesRequest.userId
    };

    const queryParams = {
      "page": listMfaTotpDevicesRequest.page,
      "limit": listMfaTotpDevicesRequest.limit,
      "sortBy": listMfaTotpDevicesRequest.sortBy,
      "sortOrder": listMfaTotpDevicesRequest.sortOrder
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/mfaTotpDevices",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListMfaTotpDevicesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "MfaTotpDeviceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.MfaTotpDeviceSummary objects
   * contained in responses from the listMfaTotpDevices operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMfaTotpDevices(
    request: requests.ListMfaTotpDevicesRequest
  ): AsyncIterableIterator<models.MfaTotpDeviceSummary> {
    return paginateRecords(request, req => this.listMfaTotpDevices(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listMfaTotpDevices operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllMfaTotpDevicesResponses(
    request: requests.ListMfaTotpDevicesRequest
  ): AsyncIterableIterator<responses.ListMfaTotpDevicesResponse> {
    return paginateResponses(request, req => this.listMfaTotpDevices(req));
  }

  /**
   * Lists the network sources in your tenancy. You must specify your tenancy's OCID as the value for
   * the compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListNetworkSourcesRequest
   * @return ListNetworkSourcesResponse
   * @throws OciError when an error occurs
   */
  public async listNetworkSources(
    listNetworkSourcesRequest: requests.ListNetworkSourcesRequest
  ): Promise<responses.ListNetworkSourcesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listNetworkSourcesRequest.compartmentId,
      "page": listNetworkSourcesRequest.page,
      "limit": listNetworkSourcesRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSources",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListNetworkSourcesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "NetworkSourcesSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.NetworkSourcesSummary objects
   * contained in responses from the listNetworkSources operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSources(
    request: requests.ListNetworkSourcesRequest
  ): AsyncIterableIterator<models.NetworkSourcesSummary> {
    return paginateRecords(request, req => this.listNetworkSources(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listNetworkSources operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllNetworkSourcesResponses(
    request: requests.ListNetworkSourcesRequest
  ): AsyncIterableIterator<responses.ListNetworkSourcesResponse> {
    return paginateResponses(request, req => this.listNetworkSources(req));
  }

  /**
   * List of Oauth tokens for the user
   *
   * @param ListOAuthClientCredentialsRequest
   * @return ListOAuthClientCredentialsResponse
   * @throws OciError when an error occurs
   */
  public async listOAuthClientCredentials(
    listOAuthClientCredentialsRequest: requests.ListOAuthClientCredentialsRequest
  ): Promise<responses.ListOAuthClientCredentialsResponse> {
    const pathParams = {
      "{userId}": listOAuthClientCredentialsRequest.userId
    };

    const queryParams = {
      "page": listOAuthClientCredentialsRequest.page,
      "limit": listOAuthClientCredentialsRequest.limit,
      "lifecycleState": listOAuthClientCredentialsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/oauth2ClientCredentials",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOAuthClientCredentialsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "OAuth2ClientCredentialSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.OAuth2ClientCredentialSummary objects
   * contained in responses from the listOAuthClientCredentials operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllOAuthClientCredentials(
    request: requests.ListOAuthClientCredentialsRequest
  ): AsyncIterableIterator<models.OAuth2ClientCredentialSummary> {
    return paginateRecords(request, req => this.listOAuthClientCredentials(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listOAuthClientCredentials operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllOAuthClientCredentialsResponses(
    request: requests.ListOAuthClientCredentialsRequest
  ): AsyncIterableIterator<responses.ListOAuthClientCredentialsResponse> {
    return paginateResponses(request, req => this.listOAuthClientCredentials(req));
  }

  /**
     * Lists the policies in the specified compartment (either the tenancy or another of your compartments).
* See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
* <p>
To determine which policies apply to a particular group or compartment, you must view the individual
* statements inside all your policies. There isn't a way to automatically obtain that information via the API.
* 
     * @param ListPoliciesRequest
     * @return ListPoliciesResponse
     * @throws OciError when an error occurs
     */
  public async listPolicies(
    listPoliciesRequest: requests.ListPoliciesRequest
  ): Promise<responses.ListPoliciesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listPoliciesRequest.compartmentId,
      "page": listPoliciesRequest.page,
      "limit": listPoliciesRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/policies",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListPoliciesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Policy[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Policy objects
   * contained in responses from the listPolicies operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPolicies(
    request: requests.ListPoliciesRequest
  ): AsyncIterableIterator<models.Policy> {
    return paginateRecords(request, req => this.listPolicies(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listPolicies operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllPoliciesResponses(
    request: requests.ListPoliciesRequest
  ): AsyncIterableIterator<responses.ListPoliciesResponse> {
    return paginateResponses(request, req => this.listPolicies(req));
  }

  /**
   * Lists the region subscriptions for the specified tenancy.
   * @param ListRegionSubscriptionsRequest
   * @return ListRegionSubscriptionsResponse
   * @throws OciError when an error occurs
   */
  public async listRegionSubscriptions(
    listRegionSubscriptionsRequest: requests.ListRegionSubscriptionsRequest
  ): Promise<responses.ListRegionSubscriptionsResponse> {
    const pathParams = {
      "{tenancyId}": listRegionSubscriptionsRequest.tenancyId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tenancies/{tenancyId}/regionSubscriptions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRegionSubscriptionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "RegionSubscription[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists all the regions offered by Oracle Cloud Infrastructure.
   * @param ListRegionsRequest
   * @return ListRegionsResponse
   * @throws OciError when an error occurs
   */
  public async listRegions(
    listRegionsRequest: requests.ListRegionsRequest
  ): Promise<responses.ListRegionsResponse> {
    const pathParams = {};

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/regions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListRegionsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "Region[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the SMTP credentials for the specified user. The returned object contains the credential's OCID,
   * the SMTP user name but not the SMTP password. The SMTP password is returned only upon creation.
   *
   * @param ListSmtpCredentialsRequest
   * @return ListSmtpCredentialsResponse
   * @throws OciError when an error occurs
   */
  public async listSmtpCredentials(
    listSmtpCredentialsRequest: requests.ListSmtpCredentialsRequest
  ): Promise<responses.ListSmtpCredentialsResponse> {
    const pathParams = {
      "{userId}": listSmtpCredentialsRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/smtpCredentials",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSmtpCredentialsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SmtpCredentialSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * **Deprecated. Use {@link #listAuthTokens(ListAuthTokensRequest) listAuthTokens} instead.**
* <p>
Lists the Swift passwords for the specified user. The returned object contains the password's OCID, but not
* the password itself. The actual password is returned only upon creation.
* 
     * @param ListSwiftPasswordsRequest
     * @return ListSwiftPasswordsResponse
     * @throws OciError when an error occurs
     */
  public async listSwiftPasswords(
    listSwiftPasswordsRequest: requests.ListSwiftPasswordsRequest
  ): Promise<responses.ListSwiftPasswordsResponse> {
    const pathParams = {
      "{userId}": listSwiftPasswordsRequest.userId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/swiftPasswords",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSwiftPasswordsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SwiftPassword[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Lists the tag defaults for tag definitions in the specified compartment.
   *
   * @param ListTagDefaultsRequest
   * @return ListTagDefaultsResponse
   * @throws OciError when an error occurs
   */
  public async listTagDefaults(
    listTagDefaultsRequest: requests.ListTagDefaultsRequest
  ): Promise<responses.ListTagDefaultsResponse> {
    const pathParams = {};

    const queryParams = {
      "page": listTagDefaultsRequest.page,
      "limit": listTagDefaultsRequest.limit,
      "id": listTagDefaultsRequest.id,
      "compartmentId": listTagDefaultsRequest.compartmentId,
      "tagDefinitionId": listTagDefaultsRequest.tagDefinitionId,
      "lifecycleState": listTagDefaultsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTagDefaultsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TagDefaultSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TagDefaultSummary objects
   * contained in responses from the listTagDefaults operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTagDefaults(
    request: requests.ListTagDefaultsRequest
  ): AsyncIterableIterator<models.TagDefaultSummary> {
    return paginateRecords(request, req => this.listTagDefaults(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTagDefaults operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTagDefaultsResponses(
    request: requests.ListTagDefaultsRequest
  ): AsyncIterableIterator<responses.ListTagDefaultsResponse> {
    return paginateResponses(request, req => this.listTagDefaults(req));
  }

  /**
   * Lists the tag namespaces in the specified compartment.
   *
   * @param ListTagNamespacesRequest
   * @return ListTagNamespacesResponse
   * @throws OciError when an error occurs
   */
  public async listTagNamespaces(
    listTagNamespacesRequest: requests.ListTagNamespacesRequest
  ): Promise<responses.ListTagNamespacesResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listTagNamespacesRequest.compartmentId,
      "page": listTagNamespacesRequest.page,
      "limit": listTagNamespacesRequest.limit,
      "includeSubcompartments": listTagNamespacesRequest.includeSubcompartments,
      "lifecycleState": listTagNamespacesRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTagNamespacesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TagNamespaceSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TagNamespaceSummary objects
   * contained in responses from the listTagNamespaces operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTagNamespaces(
    request: requests.ListTagNamespacesRequest
  ): AsyncIterableIterator<models.TagNamespaceSummary> {
    return paginateRecords(request, req => this.listTagNamespaces(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTagNamespaces operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTagNamespacesResponses(
    request: requests.ListTagNamespacesRequest
  ): AsyncIterableIterator<responses.ListTagNamespacesResponse> {
    return paginateResponses(request, req => this.listTagNamespaces(req));
  }

  /**
   * Gets the errors for a work request.
   *
   * @param ListTaggingWorkRequestErrorsRequest
   * @return ListTaggingWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   */
  public async listTaggingWorkRequestErrors(
    listTaggingWorkRequestErrorsRequest: requests.ListTaggingWorkRequestErrorsRequest
  ): Promise<responses.ListTaggingWorkRequestErrorsResponse> {
    const pathParams = {
      "{workRequestId}": listTaggingWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listTaggingWorkRequestErrorsRequest.page,
      "limit": listTaggingWorkRequestErrorsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/taggingWorkRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaggingWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TaggingWorkRequestErrorSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TaggingWorkRequestErrorSummary objects
   * contained in responses from the listTaggingWorkRequestErrors operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequestErrors(
    request: requests.ListTaggingWorkRequestErrorsRequest
  ): AsyncIterableIterator<models.TaggingWorkRequestErrorSummary> {
    return paginateRecords(request, req => this.listTaggingWorkRequestErrors(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTaggingWorkRequestErrors operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequestErrorsResponses(
    request: requests.ListTaggingWorkRequestErrorsRequest
  ): AsyncIterableIterator<responses.ListTaggingWorkRequestErrorsResponse> {
    return paginateResponses(request, req => this.listTaggingWorkRequestErrors(req));
  }

  /**
   * Gets the logs for a work request.
   *
   * @param ListTaggingWorkRequestLogsRequest
   * @return ListTaggingWorkRequestLogsResponse
   * @throws OciError when an error occurs
   */
  public async listTaggingWorkRequestLogs(
    listTaggingWorkRequestLogsRequest: requests.ListTaggingWorkRequestLogsRequest
  ): Promise<responses.ListTaggingWorkRequestLogsResponse> {
    const pathParams = {
      "{workRequestId}": listTaggingWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listTaggingWorkRequestLogsRequest.page,
      "limit": listTaggingWorkRequestLogsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/taggingWorkRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaggingWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TaggingWorkRequestLogSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TaggingWorkRequestLogSummary objects
   * contained in responses from the listTaggingWorkRequestLogs operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequestLogs(
    request: requests.ListTaggingWorkRequestLogsRequest
  ): AsyncIterableIterator<models.TaggingWorkRequestLogSummary> {
    return paginateRecords(request, req => this.listTaggingWorkRequestLogs(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTaggingWorkRequestLogs operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequestLogsResponses(
    request: requests.ListTaggingWorkRequestLogsRequest
  ): AsyncIterableIterator<responses.ListTaggingWorkRequestLogsResponse> {
    return paginateResponses(request, req => this.listTaggingWorkRequestLogs(req));
  }

  /**
   * Lists the tagging work requests in compartment.
   *
   * @param ListTaggingWorkRequestsRequest
   * @return ListTaggingWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listTaggingWorkRequests(
    listTaggingWorkRequestsRequest: requests.ListTaggingWorkRequestsRequest
  ): Promise<responses.ListTaggingWorkRequestsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listTaggingWorkRequestsRequest.compartmentId,
      "page": listTaggingWorkRequestsRequest.page,
      "limit": listTaggingWorkRequestsRequest.limit,
      "resourceIdentifier": listTaggingWorkRequestsRequest.resourceIdentifier
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/taggingWorkRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTaggingWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TaggingWorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TaggingWorkRequestSummary objects
   * contained in responses from the listTaggingWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequests(
    request: requests.ListTaggingWorkRequestsRequest
  ): AsyncIterableIterator<models.TaggingWorkRequestSummary> {
    return paginateRecords(request, req => this.listTaggingWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTaggingWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTaggingWorkRequestsResponses(
    request: requests.ListTaggingWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListTaggingWorkRequestsResponse> {
    return paginateResponses(request, req => this.listTaggingWorkRequests(req));
  }

  /**
   * Lists the tag definitions in the specified tag namespace.
   *
   * @param ListTagsRequest
   * @return ListTagsResponse
   * @throws OciError when an error occurs
   */
  public async listTags(
    listTagsRequest: requests.ListTagsRequest
  ): Promise<responses.ListTagsResponse> {
    const pathParams = {
      "{tagNamespaceId}": listTagsRequest.tagNamespaceId
    };

    const queryParams = {
      "page": listTagsRequest.page,
      "limit": listTagsRequest.limit,
      "lifecycleState": listTagsRequest.lifecycleState
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/tags",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTagsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TagSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TagSummary objects
   * contained in responses from the listTags operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTags(request: requests.ListTagsRequest): AsyncIterableIterator<models.TagSummary> {
    return paginateRecords(request, req => this.listTags(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTags operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTagsResponses(
    request: requests.ListTagsRequest
  ): AsyncIterableIterator<responses.ListTagsResponse> {
    return paginateResponses(request, req => this.listTags(req));
  }

  /**
     * Lists the `UserGroupMembership` objects in your tenancy. You must specify your tenancy's OCID
* as the value for the compartment ID
* (see [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five)).
* You must also then filter the list in one of these ways:
* <p>
- You can limit the results to just the memberships for a given user by specifying a `userId`.
* - Similarly, you can limit the results to just the memberships for a given group by specifying a `groupId`.
* - You can set both the `userId` and `groupId` to determine if the specified user is in the specified group.
* If the answer is no, the response is an empty list.
* - Although`userId` and `groupId` are not individually required, you must set one of them.
* 
     * @param ListUserGroupMembershipsRequest
     * @return ListUserGroupMembershipsResponse
     * @throws OciError when an error occurs
     */
  public async listUserGroupMemberships(
    listUserGroupMembershipsRequest: requests.ListUserGroupMembershipsRequest
  ): Promise<responses.ListUserGroupMembershipsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listUserGroupMembershipsRequest.compartmentId,
      "userId": listUserGroupMembershipsRequest.userId,
      "groupId": listUserGroupMembershipsRequest.groupId,
      "page": listUserGroupMembershipsRequest.page,
      "limit": listUserGroupMembershipsRequest.limit
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/userGroupMemberships",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListUserGroupMembershipsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "UserGroupMembership[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.UserGroupMembership objects
   * contained in responses from the listUserGroupMemberships operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllUserGroupMemberships(
    request: requests.ListUserGroupMembershipsRequest
  ): AsyncIterableIterator<models.UserGroupMembership> {
    return paginateRecords(request, req => this.listUserGroupMemberships(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listUserGroupMemberships operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllUserGroupMembershipsResponses(
    request: requests.ListUserGroupMembershipsRequest
  ): AsyncIterableIterator<responses.ListUserGroupMembershipsResponse> {
    return paginateResponses(request, req => this.listUserGroupMemberships(req));
  }

  /**
   * Lists the users in your tenancy. You must specify your tenancy's OCID as the value for the
   * compartment ID (remember that the tenancy is simply the root compartment).
   * See [Where to Get the Tenancy's OCID and User's OCID](https://docs.cloud.oracle.com/Content/API/Concepts/apisigningkey.htm#five).
   *
   * @param ListUsersRequest
   * @return ListUsersResponse
   * @throws OciError when an error occurs
   */
  public async listUsers(
    listUsersRequest: requests.ListUsersRequest
  ): Promise<responses.ListUsersResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listUsersRequest.compartmentId,
      "page": listUsersRequest.page,
      "limit": listUsersRequest.limit,
      "identityProviderId": listUsersRequest.identityProviderId,
      "externalIdentifier": listUsersRequest.externalIdentifier
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListUsersResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "User[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.User objects
   * contained in responses from the listUsers operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllUsers(request: requests.ListUsersRequest): AsyncIterableIterator<models.User> {
    return paginateRecords(request, req => this.listUsers(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listUsers operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllUsersResponses(
    request: requests.ListUsersRequest
  ): AsyncIterableIterator<responses.ListUsersResponse> {
    return paginateResponses(request, req => this.listUsers(req));
  }

  /**
   * Lists the work requests in compartment.
   *
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit,
      "resourceIdentifier": listWorkRequestsRequest.resourceIdentifier
    };

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "WorkRequestSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.WorkRequestSummary objects
   * contained in responses from the listWorkRequests operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequests(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<models.WorkRequestSummary> {
    return paginateRecords(request, req => this.listWorkRequests(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listWorkRequests operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllWorkRequestsResponses(
    request: requests.ListWorkRequestsRequest
  ): AsyncIterableIterator<responses.ListWorkRequestsResponse> {
    return paginateResponses(request, req => this.listWorkRequests(req));
  }

  /**
   * Move the compartment to a different parent compartment in the same tenancy. When you move a
   * compartment, all its contents (subcompartments and resources) are moved with it. Note that
   * the `CompartmentId` that you specify in the path is the compartment that you want to move.
   * <p>
   **IMPORTANT**: After you move a compartment to a new parent compartment, the access policies of
   * the new parent take effect and the policies of the previous parent no longer apply. Ensure that you
   * are aware of the implications for the compartment contents before you move it. For more
   * information, see [Moving a Compartment](https://docs.cloud.oracle.com/Content/Identity/Tasks/managingcompartments.htm#MoveCompartment).
   *
   * @param MoveCompartmentRequest
   * @return MoveCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async moveCompartment(
    moveCompartmentRequest: requests.MoveCompartmentRequest
  ): Promise<responses.MoveCompartmentResponse> {
    const pathParams = {
      "{compartmentId}": moveCompartmentRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": moveCompartmentRequest.ifMatch,
      "opc-request-id": moveCompartmentRequest.opcRequestId,
      "opc-retry-token": moveCompartmentRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}/actions/moveCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        moveCompartmentRequest.moveCompartmentDetails,
        "MoveCompartmentDetails",
        models.MoveCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.MoveCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Recover the compartment from DELETED state to ACTIVE state.
   *
   * @param RecoverCompartmentRequest
   * @return RecoverCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async recoverCompartment(
    recoverCompartmentRequest: requests.RecoverCompartmentRequest
  ): Promise<responses.RecoverCompartmentResponse> {
    const pathParams = {
      "{compartmentId}": recoverCompartmentRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": recoverCompartmentRequest.ifMatch,
      "opc-request-id": recoverCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}/actions/recoverCompartment",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RecoverCompartmentResponse>{},
        body: await response.json(),
        bodyKey: "compartment",
        bodyModel: "model.Compartment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Removes a user from a group by deleting the corresponding `UserGroupMembership`.
   * @param RemoveUserFromGroupRequest
   * @return RemoveUserFromGroupResponse
   * @throws OciError when an error occurs
   */
  public async removeUserFromGroup(
    removeUserFromGroupRequest: requests.RemoveUserFromGroupRequest
  ): Promise<responses.RemoveUserFromGroupResponse> {
    const pathParams = {
      "{userGroupMembershipId}": removeUserFromGroupRequest.userGroupMembershipId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": removeUserFromGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/userGroupMemberships/{userGroupMembershipId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.RemoveUserFromGroupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Resets the OAuth2 client credentials for the SCIM client associated with this identity provider.
   *
   * @param ResetIdpScimClientRequest
   * @return ResetIdpScimClientResponse
   * @throws OciError when an error occurs
   */
  public async resetIdpScimClient(
    resetIdpScimClientRequest: requests.ResetIdpScimClientRequest
  ): Promise<responses.ResetIdpScimClientResponse> {
    const pathParams = {
      "{identityProviderId}": resetIdpScimClientRequest.identityProviderId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/actions/resetScimClient",
      method: "POST",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ResetIdpScimClientResponse>{},
        body: await response.json(),
        bodyKey: "scimClientCredentials",
        bodyModel: "model.ScimClientCredentials",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified auth token's description.
   *
   * @param UpdateAuthTokenRequest
   * @return UpdateAuthTokenResponse
   * @throws OciError when an error occurs
   */
  public async updateAuthToken(
    updateAuthTokenRequest: requests.UpdateAuthTokenRequest
  ): Promise<responses.UpdateAuthTokenResponse> {
    const pathParams = {
      "{userId}": updateAuthTokenRequest.userId,
      "{authTokenId}": updateAuthTokenRequest.authTokenId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAuthTokenRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/authTokens/{authTokenId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAuthTokenRequest.updateAuthTokenDetails,
        "UpdateAuthTokenDetails",
        models.UpdateAuthTokenDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAuthTokenResponse>{},
        body: await response.json(),
        bodyKey: "authToken",
        bodyModel: "model.AuthToken",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates authentication policy for the specified tenancy
   *
   * @param UpdateAuthenticationPolicyRequest
   * @return UpdateAuthenticationPolicyResponse
   * @throws OciError when an error occurs
   */
  public async updateAuthenticationPolicy(
    updateAuthenticationPolicyRequest: requests.UpdateAuthenticationPolicyRequest
  ): Promise<responses.UpdateAuthenticationPolicyResponse> {
    const pathParams = {
      "{compartmentId}": updateAuthenticationPolicyRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateAuthenticationPolicyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/authenticationPolicies/{compartmentId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateAuthenticationPolicyRequest.updateAuthenticationPolicyDetails,
        "UpdateAuthenticationPolicyDetails",
        models.UpdateAuthenticationPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateAuthenticationPolicyResponse>{},
        body: await response.json(),
        bodyKey: "authenticationPolicy",
        bodyModel: "model.AuthenticationPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified compartment's description or name. You can't update the root compartment.
   * @param UpdateCompartmentRequest
   * @return UpdateCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async updateCompartment(
    updateCompartmentRequest: requests.UpdateCompartmentRequest
  ): Promise<responses.UpdateCompartmentResponse> {
    const pathParams = {
      "{compartmentId}": updateCompartmentRequest.compartmentId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCompartmentRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/compartments/{compartmentId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCompartmentRequest.updateCompartmentDetails,
        "UpdateCompartmentDetails",
        models.UpdateCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCompartmentResponse>{},
        body: await response.json(),
        bodyKey: "compartment",
        bodyModel: "model.Compartment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified secret key's description.
   *
   * @param UpdateCustomerSecretKeyRequest
   * @return UpdateCustomerSecretKeyResponse
   * @throws OciError when an error occurs
   */
  public async updateCustomerSecretKey(
    updateCustomerSecretKeyRequest: requests.UpdateCustomerSecretKeyRequest
  ): Promise<responses.UpdateCustomerSecretKeyResponse> {
    const pathParams = {
      "{userId}": updateCustomerSecretKeyRequest.userId,
      "{customerSecretKeyId}": updateCustomerSecretKeyRequest.customerSecretKeyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateCustomerSecretKeyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/customerSecretKeys/{customerSecretKeyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateCustomerSecretKeyRequest.updateCustomerSecretKeyDetails,
        "UpdateCustomerSecretKeyDetails",
        models.UpdateCustomerSecretKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateCustomerSecretKeyResponse>{},
        body: await response.json(),
        bodyKey: "customerSecretKeySummary",
        bodyModel: "model.CustomerSecretKeySummary",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified dynamic group.
   * @param UpdateDynamicGroupRequest
   * @return UpdateDynamicGroupResponse
   * @throws OciError when an error occurs
   */
  public async updateDynamicGroup(
    updateDynamicGroupRequest: requests.UpdateDynamicGroupRequest
  ): Promise<responses.UpdateDynamicGroupResponse> {
    const pathParams = {
      "{dynamicGroupId}": updateDynamicGroupRequest.dynamicGroupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateDynamicGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/dynamicGroups/{dynamicGroupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDynamicGroupRequest.updateDynamicGroupDetails,
        "UpdateDynamicGroupDetails",
        models.UpdateDynamicGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDynamicGroupResponse>{},
        body: await response.json(),
        bodyKey: "dynamicGroup",
        bodyModel: "model.DynamicGroup",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified group.
   * @param UpdateGroupRequest
   * @return UpdateGroupResponse
   * @throws OciError when an error occurs
   */
  public async updateGroup(
    updateGroupRequest: requests.UpdateGroupRequest
  ): Promise<responses.UpdateGroupResponse> {
    const pathParams = {
      "{groupId}": updateGroupRequest.groupId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateGroupRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/groups/{groupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateGroupRequest.updateGroupDetails,
        "UpdateGroupDetails",
        models.UpdateGroupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateGroupResponse>{},
        body: await response.json(),
        bodyKey: "group",
        bodyModel: "model.Group",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified identity provider.
   * @param UpdateIdentityProviderRequest
   * @return UpdateIdentityProviderResponse
   * @throws OciError when an error occurs
   */
  public async updateIdentityProvider(
    updateIdentityProviderRequest: requests.UpdateIdentityProviderRequest
  ): Promise<responses.UpdateIdentityProviderResponse> {
    const pathParams = {
      "{identityProviderId}": updateIdentityProviderRequest.identityProviderId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIdentityProviderRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIdentityProviderRequest.updateIdentityProviderDetails,
        "UpdateIdentityProviderDetails",
        models.UpdateIdentityProviderDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIdentityProviderResponse>{},
        body: await response.json(),
        bodyKey: "identityProvider",
        bodyModel: "model.IdentityProvider",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified group mapping.
   * @param UpdateIdpGroupMappingRequest
   * @return UpdateIdpGroupMappingResponse
   * @throws OciError when an error occurs
   */
  public async updateIdpGroupMapping(
    updateIdpGroupMappingRequest: requests.UpdateIdpGroupMappingRequest
  ): Promise<responses.UpdateIdpGroupMappingResponse> {
    const pathParams = {
      "{identityProviderId}": updateIdpGroupMappingRequest.identityProviderId,
      "{mappingId}": updateIdpGroupMappingRequest.mappingId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateIdpGroupMappingRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/identityProviders/{identityProviderId}/groupMappings/{mappingId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIdpGroupMappingRequest.updateIdpGroupMappingDetails,
        "UpdateIdpGroupMappingDetails",
        models.UpdateIdpGroupMappingDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIdpGroupMappingResponse>{},
        body: await response.json(),
        bodyKey: "idpGroupMapping",
        bodyModel: "model.IdpGroupMapping",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified network source.
   * @param UpdateNetworkSourceRequest
   * @return UpdateNetworkSourceResponse
   * @throws OciError when an error occurs
   */
  public async updateNetworkSource(
    updateNetworkSourceRequest: requests.UpdateNetworkSourceRequest
  ): Promise<responses.UpdateNetworkSourceResponse> {
    const pathParams = {
      "{networkSourceId}": updateNetworkSourceRequest.networkSourceId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateNetworkSourceRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/networkSources/{networkSourceId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateNetworkSourceRequest.updateNetworkSourceDetails,
        "UpdateNetworkSourceDetails",
        models.UpdateNetworkSourceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateNetworkSourceResponse>{},
        body: await response.json(),
        bodyKey: "networkSources",
        bodyModel: "model.NetworkSources",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates Oauth token for the user
   *
   * @param UpdateOAuthClientCredentialRequest
   * @return UpdateOAuthClientCredentialResponse
   * @throws OciError when an error occurs
   */
  public async updateOAuthClientCredential(
    updateOAuthClientCredentialRequest: requests.UpdateOAuthClientCredentialRequest
  ): Promise<responses.UpdateOAuthClientCredentialResponse> {
    const pathParams = {
      "{userId}": updateOAuthClientCredentialRequest.userId,
      "{oauth2ClientCredentialId}": updateOAuthClientCredentialRequest.oauth2ClientCredentialId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateOAuthClientCredentialRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/oauth2ClientCredentials/{oauth2ClientCredentialId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateOAuthClientCredentialRequest.updateOAuth2ClientCredentialDetails,
        "UpdateOAuth2ClientCredentialDetails",
        models.UpdateOAuth2ClientCredentialDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateOAuthClientCredentialResponse>{},
        body: await response.json(),
        bodyKey: "oAuth2ClientCredential",
        bodyModel: "model.OAuth2ClientCredential",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified policy. You can update the description or the policy statements themselves.
* <p>
Policy changes take effect typically within 10 seconds.
* 
     * @param UpdatePolicyRequest
     * @return UpdatePolicyResponse
     * @throws OciError when an error occurs
     */
  public async updatePolicy(
    updatePolicyRequest: requests.UpdatePolicyRequest
  ): Promise<responses.UpdatePolicyResponse> {
    const pathParams = {
      "{policyId}": updatePolicyRequest.policyId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updatePolicyRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/policies/{policyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updatePolicyRequest.updatePolicyDetails,
        "UpdatePolicyDetails",
        models.UpdatePolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdatePolicyResponse>{},
        body: await response.json(),
        bodyKey: "policy",
        bodyModel: "model.Policy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified SMTP credential's description.
   *
   * @param UpdateSmtpCredentialRequest
   * @return UpdateSmtpCredentialResponse
   * @throws OciError when an error occurs
   */
  public async updateSmtpCredential(
    updateSmtpCredentialRequest: requests.UpdateSmtpCredentialRequest
  ): Promise<responses.UpdateSmtpCredentialResponse> {
    const pathParams = {
      "{userId}": updateSmtpCredentialRequest.userId,
      "{smtpCredentialId}": updateSmtpCredentialRequest.smtpCredentialId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateSmtpCredentialRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/smtpCredentials/{smtpCredentialId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSmtpCredentialRequest.updateSmtpCredentialDetails,
        "UpdateSmtpCredentialDetails",
        models.UpdateSmtpCredentialDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSmtpCredentialResponse>{},
        body: await response.json(),
        bodyKey: "smtpCredentialSummary",
        bodyModel: "model.SmtpCredentialSummary",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * **Deprecated. Use {@link #updateAuthToken(UpdateAuthTokenRequest) updateAuthToken} instead.**
* <p>
Updates the specified Swift password's description.
* 
     * @param UpdateSwiftPasswordRequest
     * @return UpdateSwiftPasswordResponse
     * @throws OciError when an error occurs
     */
  public async updateSwiftPassword(
    updateSwiftPasswordRequest: requests.UpdateSwiftPasswordRequest
  ): Promise<responses.UpdateSwiftPasswordResponse> {
    const pathParams = {
      "{userId}": updateSwiftPasswordRequest.userId,
      "{swiftPasswordId}": updateSwiftPasswordRequest.swiftPasswordId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateSwiftPasswordRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/swiftPasswords/{swiftPasswordId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSwiftPasswordRequest.updateSwiftPasswordDetails,
        "UpdateSwiftPasswordDetails",
        models.UpdateSwiftPasswordDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSwiftPasswordResponse>{},
        body: await response.json(),
        bodyKey: "swiftPassword",
        bodyModel: "model.SwiftPassword",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the specified tag definition.
* <p>
Setting `validator` determines the value type. Tags can use either a static value or a 
* list of possible values. Static values are entered by a user applying the tag to a resource. 
* Lists are created by you and the user must apply a value from the list. On update, any values
* in a list that were previously set do not change, but new values must pass validation. Values 
* already applied to a resource do not change. 
* <p>
You cannot remove list values that appear in a TagDefault. To remove a list value that 
* appears in a TagDefault, first update the TagDefault to use a different value.
* 
     * @param UpdateTagRequest
     * @return UpdateTagResponse
     * @throws OciError when an error occurs
     */
  public async updateTag(
    updateTagRequest: requests.UpdateTagRequest
  ): Promise<responses.UpdateTagResponse> {
    const pathParams = {
      "{tagNamespaceId}": updateTagRequest.tagNamespaceId,
      "{tagName}": updateTagRequest.tagName
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateTagRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}/tags/{tagName}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTagRequest.updateTagDetails,
        "UpdateTagDetails",
        models.UpdateTagDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTagResponse>{},
        body: await response.json(),
        bodyKey: "tag",
        bodyModel: "model.Tag",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the specified tag default. If you specify that a value is required, a value is set
   * during resource creation (either by the user creating the resource or another tag defualt).
   * If no value is set, resource creation is blocked.
   * <p>
   * If the `isRequired` flag is set to \"true\", the value is set during resource creation.
   * * If the `isRequired` flag is set to \"false\", the value you enter is set during resource creation.
   *
   * @param UpdateTagDefaultRequest
   * @return UpdateTagDefaultResponse
   * @throws OciError when an error occurs
   */
  public async updateTagDefault(
    updateTagDefaultRequest: requests.UpdateTagDefaultRequest
  ): Promise<responses.UpdateTagDefaultResponse> {
    const pathParams = {
      "{tagDefaultId}": updateTagDefaultRequest.tagDefaultId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateTagDefaultRequest.ifMatch,
      "opc-request-id": updateTagDefaultRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagDefaults/{tagDefaultId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTagDefaultRequest.updateTagDefaultDetails,
        "UpdateTagDefaultDetails",
        models.UpdateTagDefaultDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTagDefaultResponse>{},
        body: await response.json(),
        bodyKey: "tagDefault",
        bodyModel: "model.TagDefault",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Updates the the specified tag namespace. You can't update the namespace name.
* <p>
Updating `isRetired` to 'true' retires the namespace and all the tag definitions in the namespace. Reactivating a
* namespace (changing `isRetired` from 'true' to 'false') does not reactivate tag definitions.
* To reactivate the tag definitions, you must reactivate each one individually *after* you reactivate the namespace,
* using {@link #updateTag(UpdateTagRequest) updateTag}. For more information about retiring tag namespaces, see
* [Retiring Key Definitions and Namespace Definitions](https://docs.cloud.oracle.com/Content/Identity/Concepts/taggingoverview.htm#Retiring).
* <p>
You can't add a namespace with the same name as a retired namespace in the same tenancy.
* 
     * @param UpdateTagNamespaceRequest
     * @return UpdateTagNamespaceResponse
     * @throws OciError when an error occurs
     */
  public async updateTagNamespace(
    updateTagNamespaceRequest: requests.UpdateTagNamespaceRequest
  ): Promise<responses.UpdateTagNamespaceResponse> {
    const pathParams = {
      "{tagNamespaceId}": updateTagNamespaceRequest.tagNamespaceId
    };

    const queryParams = {};

    let headerParams = {};

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tagNamespaces/{tagNamespaceId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTagNamespaceRequest.updateTagNamespaceDetails,
        "UpdateTagNamespaceDetails",
        models.UpdateTagNamespaceDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTagNamespaceResponse>{},
        body: await response.json(),
        bodyKey: "tagNamespace",
        bodyModel: "model.TagNamespace",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the description of the specified user.
   * @param UpdateUserRequest
   * @return UpdateUserResponse
   * @throws OciError when an error occurs
   */
  public async updateUser(
    updateUserRequest: requests.UpdateUserRequest
  ): Promise<responses.UpdateUserResponse> {
    const pathParams = {
      "{userId}": updateUserRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateUserRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateUserRequest.updateUserDetails,
        "UpdateUserDetails",
        models.UpdateUserDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateUserResponse>{},
        body: await response.json(),
        bodyKey: "user",
        bodyModel: "model.User",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the capabilities of the specified user.
   *
   * @param UpdateUserCapabilitiesRequest
   * @return UpdateUserCapabilitiesResponse
   * @throws OciError when an error occurs
   */
  public async updateUserCapabilities(
    updateUserCapabilitiesRequest: requests.UpdateUserCapabilitiesRequest
  ): Promise<responses.UpdateUserCapabilitiesResponse> {
    const pathParams = {
      "{userId}": updateUserCapabilitiesRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateUserCapabilitiesRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/capabilities",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateUserCapabilitiesRequest.updateUserCapabilitiesDetails,
        "UpdateUserCapabilitiesDetails",
        models.UpdateUserCapabilitiesDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateUserCapabilitiesResponse>{},
        body: await response.json(),
        bodyKey: "user",
        bodyModel: "model.User",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Updates the state of the specified user.
   *
   * @param UpdateUserStateRequest
   * @return UpdateUserStateResponse
   * @throws OciError when an error occurs
   */
  public async updateUserState(
    updateUserStateRequest: requests.UpdateUserStateRequest
  ): Promise<responses.UpdateUserStateResponse> {
    const pathParams = {
      "{userId}": updateUserStateRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "if-match": updateUserStateRequest.ifMatch
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/state",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateUserStateRequest.updateStateDetails,
        "UpdateStateDetails",
        models.UpdateStateDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateUserStateResponse>{},
        body: await response.json(),
        bodyKey: "user",
        bodyModel: "model.User",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
     * Uploads an API signing key for the specified user.
* <p>
Every user has permission to use this operation to upload a key for *their own user ID*. An
* administrator in your organization does not need to write a policy to give users this ability.
* To compare, administrators who have permission to the tenancy can use this operation to upload a
* key for any user, including themselves.
* <p>
**Important:** Even though you have permission to upload an API key, you might not yet
* have permission to do much else. If you try calling an operation unrelated to your own credential
* management (e.g., `ListUsers`, `LaunchInstance`) and receive an \"unauthorized\" error,
* check with an administrator to confirm which IAM Service group(s) you're in and what access
* you have. Also confirm you're working in the correct compartment.
* <p>
After you send your request, the new object's `lifecycleState` will temporarily be CREATING. Before using
* the object, first make sure its `lifecycleState` has changed to ACTIVE.
* 
     * @param UploadApiKeyRequest
     * @return UploadApiKeyResponse
     * @throws OciError when an error occurs
     */
  public async uploadApiKey(
    uploadApiKeyRequest: requests.UploadApiKeyRequest
  ): Promise<responses.UploadApiKeyResponse> {
    const pathParams = {
      "{userId}": uploadApiKeyRequest.userId
    };

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": uploadApiKeyRequest.opcRetryToken
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/users/{userId}/apiKeys",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        uploadApiKeyRequest.createApiKeyDetails,
        "CreateApiKeyDetails",
        models.CreateApiKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const response = await this._httpClient.send(request);
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UploadApiKeyResponse>{},
        body: await response.json(),
        bodyKey: "apiKey",
        bodyModel: "model.ApiKey",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
