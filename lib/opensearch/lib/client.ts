/**
 * OpenSearch Service API
 * The OpenSearch service API provides access to OCI Search Service with OpenSearch.
 * OpenAPI spec version: 20180828
 *
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as model from "./model";
import * as responses from "./response";
import { OpensearchClusterWaiter } from "./opensearchcluster-waiter";
import { OpensearchClusterBackupWaiter } from "./opensearchclusterbackup-waiter";
import { OpensearchClusterPipelineWaiter } from "./opensearchclusterpipeline-waiter";
import {
  composeResponse,
  composeRequest,
  GenericRetrier,
  developerToolConfiguration
} from "oci-common";
const Breaker = require("opossum");

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum OpensearchClusterApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class OpensearchClusterClient {
  protected static serviceEndpointTemplate =
    "https://search-indexing.{region}.oci.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": OpensearchClusterWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "OpensearchCluster";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("opensearch")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("opensearch");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180828";
    if (this.logger) this.logger.info(`OpensearchClusterClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        OpensearchClusterClient.serviceEndpointTemplate,
        this._region,
        OpensearchClusterClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        OpensearchClusterClient.serviceEndpointTemplate,
        this._regionId,
        OpensearchClusterClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      OpensearchClusterClient.serviceEndpointTemplate,
      region,
      OpensearchClusterClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      OpensearchClusterClient.serviceEndpointTemplate,
      regionId,
      OpensearchClusterClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new OpensearchClusterWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): OpensearchClusterWaiter {
    this._waiters = new OpensearchClusterWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): OpensearchClusterWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Backup the opensearch cluster details.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param BackupOpensearchClusterRequest
   * @return BackupOpensearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/BackupOpensearchCluster.ts.html |here} to see how to use BackupOpensearchCluster API.
   */
  public async backupOpensearchCluster(
    backupOpensearchClusterRequest: requests.BackupOpensearchClusterRequest
  ): Promise<responses.BackupOpensearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#backupOpensearchCluster.");
    const operationName = "backupOpensearchCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": backupOpensearchClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": backupOpensearchClusterRequest.ifMatch,
      "opc-retry-token": backupOpensearchClusterRequest.opcRetryToken,
      "opc-request-id": backupOpensearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      backupOpensearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/backup",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        backupOpensearchClusterRequest.backupOpensearchClusterDetails,
        "BackupOpensearchClusterDetails",
        model.BackupOpensearchClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.BackupOpensearchClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Configure Outbound cluster for cross-cluster operations
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ConfigureOutboundClusterRequest
   * @return ConfigureOutboundClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ConfigureOutboundCluster.ts.html |here} to see how to use ConfigureOutboundCluster API.
   */
  public async configureOutboundCluster(
    configureOutboundClusterRequest: requests.ConfigureOutboundClusterRequest
  ): Promise<responses.ConfigureOutboundClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#configureOutboundCluster.");
    const operationName = "configureOutboundCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": configureOutboundClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": configureOutboundClusterRequest.ifMatch,
      "opc-retry-token": configureOutboundClusterRequest.opcRetryToken,
      "opc-request-id": configureOutboundClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      configureOutboundClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/configureOutboundCluster",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        configureOutboundClusterRequest.configureOutboundClusterDetails,
        "ConfigureOutboundClusterDetails",
        model.ConfigureOutboundClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ConfigureOutboundClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new OpensearchCluster.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CreateOpensearchClusterRequest
   * @return CreateOpensearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/CreateOpensearchCluster.ts.html |here} to see how to use CreateOpensearchCluster API.
   */
  public async createOpensearchCluster(
    createOpensearchClusterRequest: requests.CreateOpensearchClusterRequest
  ): Promise<responses.CreateOpensearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#createOpensearchCluster.");
    const operationName = "createOpensearchCluster";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createOpensearchClusterRequest.opcRetryToken,
      "opc-request-id": createOpensearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createOpensearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createOpensearchClusterRequest.createOpensearchClusterDetails,
        "CreateOpensearchClusterDetails",
        model.CreateOpensearchClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateOpensearchClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a OpensearchCluster resource by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DeleteOpensearchClusterRequest
   * @return DeleteOpensearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/DeleteOpensearchCluster.ts.html |here} to see how to use DeleteOpensearchCluster API.
   */
  public async deleteOpensearchCluster(
    deleteOpensearchClusterRequest: requests.DeleteOpensearchClusterRequest
  ): Promise<responses.DeleteOpensearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#deleteOpensearchCluster.");
    const operationName = "deleteOpensearchCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": deleteOpensearchClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteOpensearchClusterRequest.ifMatch,
      "opc-request-id": deleteOpensearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteOpensearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteOpensearchClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a OpensearchCluster by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetOpensearchClusterRequest
   * @return GetOpensearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/GetOpensearchCluster.ts.html |here} to see how to use GetOpensearchCluster API.
   */
  public async getOpensearchCluster(
    getOpensearchClusterRequest: requests.GetOpensearchClusterRequest
  ): Promise<responses.GetOpensearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#getOpensearchCluster.");
    const operationName = "getOpensearchCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": getOpensearchClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getOpensearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getOpensearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetOpensearchClusterResponse>{},
        body: await response.json(),
        bodyKey: "opensearchCluster",
        bodyModel: model.OpensearchCluster,
        type: "model.OpensearchCluster",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets the status of the work request with the given ID.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetWorkRequestRequest
   * @return GetWorkRequestResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/GetWorkRequest.ts.html |here} to see how to use GetWorkRequest API.
   */
  public async getWorkRequest(
    getWorkRequestRequest: requests.GetWorkRequestRequest
  ): Promise<responses.GetWorkRequestResponse> {
    if (this.logger) this.logger.debug("Calling operation OpensearchClusterClient#getWorkRequest.");
    const operationName = "getWorkRequest";
    const apiReferenceLink = "";
    const pathParams = {
      "{workRequestId}": getWorkRequestRequest.workRequestId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getWorkRequestRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getWorkRequestRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetWorkRequestResponse>{},
        body: await response.json(),
        bodyKey: "workRequest",
        bodyModel: model.WorkRequest,
        type: "model.WorkRequest",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("retry-after"),
            key: "retryAfter",
            dataType: "number"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of OpensearchClusters.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListOpensearchClustersRequest
   * @return ListOpensearchClustersResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListOpensearchClusters.ts.html |here} to see how to use ListOpensearchClusters API.
   */
  public async listOpensearchClusters(
    listOpensearchClustersRequest: requests.ListOpensearchClustersRequest
  ): Promise<responses.ListOpensearchClustersResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#listOpensearchClusters.");
    const operationName = "listOpensearchClusters";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listOpensearchClustersRequest.compartmentId,
      "lifecycleState": listOpensearchClustersRequest.lifecycleState,
      "displayName": listOpensearchClustersRequest.displayName,
      "id": listOpensearchClustersRequest.id,
      "limit": listOpensearchClustersRequest.limit,
      "page": listOpensearchClustersRequest.page,
      "sortOrder": listOpensearchClustersRequest.sortOrder,
      "sortBy": listOpensearchClustersRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listOpensearchClustersRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listOpensearchClustersRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOpensearchClustersResponse>{},
        body: await response.json(),
        bodyKey: "opensearchClusterCollection",
        bodyModel: model.OpensearchClusterCollection,
        type: "model.OpensearchClusterCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists the supported Opensearch versions
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListOpensearchVersionsRequest
   * @return ListOpensearchVersionsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListOpensearchVersions.ts.html |here} to see how to use ListOpensearchVersions API.
   */
  public async listOpensearchVersions(
    listOpensearchVersionsRequest: requests.ListOpensearchVersionsRequest
  ): Promise<responses.ListOpensearchVersionsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#listOpensearchVersions.");
    const operationName = "listOpensearchVersions";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {
      "page": listOpensearchVersionsRequest.page,
      "limit": listOpensearchVersionsRequest.limit,
      "compartmentId": listOpensearchVersionsRequest.compartmentId
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listOpensearchVersionsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearch/versions",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOpensearchVersionsResponse>{},
        body: await response.json(),
        bodyKey: "opensearchVersionsCollection",
        bodyModel: model.OpensearchVersionsCollection,
        type: "model.OpensearchVersionsCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of errors for a given work request.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListWorkRequestErrorsRequest
   * @return ListWorkRequestErrorsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListWorkRequestErrors.ts.html |here} to see how to use ListWorkRequestErrors API.
   */
  public async listWorkRequestErrors(
    listWorkRequestErrorsRequest: requests.ListWorkRequestErrorsRequest
  ): Promise<responses.ListWorkRequestErrorsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#listWorkRequestErrors.");
    const operationName = "listWorkRequestErrors";
    const apiReferenceLink = "";
    const pathParams = {
      "{workRequestId}": listWorkRequestErrorsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestErrorsRequest.page,
      "limit": listWorkRequestErrorsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestErrorsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestErrorsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/errors",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestErrorsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestErrorCollection",
        bodyModel: model.WorkRequestErrorCollection,
        type: "model.WorkRequestErrorCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Return a (paginated) list of logs for a given work request.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListWorkRequestLogsRequest
   * @return ListWorkRequestLogsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListWorkRequestLogs.ts.html |here} to see how to use ListWorkRequestLogs API.
   */
  public async listWorkRequestLogs(
    listWorkRequestLogsRequest: requests.ListWorkRequestLogsRequest
  ): Promise<responses.ListWorkRequestLogsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#listWorkRequestLogs.");
    const operationName = "listWorkRequestLogs";
    const apiReferenceLink = "";
    const pathParams = {
      "{workRequestId}": listWorkRequestLogsRequest.workRequestId
    };

    const queryParams = {
      "page": listWorkRequestLogsRequest.page,
      "limit": listWorkRequestLogsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestLogsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestLogsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests/{workRequestId}/logs",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestLogsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestLogEntryCollection",
        bodyModel: model.WorkRequestLogEntryCollection,
        type: "model.WorkRequestLogEntryCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Lists the work requests in a compartment.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListWorkRequestsRequest
   * @return ListWorkRequestsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListWorkRequests.ts.html |here} to see how to use ListWorkRequests API.
   */
  public async listWorkRequests(
    listWorkRequestsRequest: requests.ListWorkRequestsRequest
  ): Promise<responses.ListWorkRequestsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#listWorkRequests.");
    const operationName = "listWorkRequests";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listWorkRequestsRequest.compartmentId,
      "workRequestId": listWorkRequestsRequest.workRequestId,
      "sourceResourceId": listWorkRequestsRequest.sourceResourceId,
      "page": listWorkRequestsRequest.page,
      "limit": listWorkRequestsRequest.limit
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listWorkRequestsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listWorkRequestsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/workRequests",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListWorkRequestsResponse>{},
        body: await response.json(),
        bodyKey: "workRequestCollection",
        bodyModel: model.WorkRequestCollection,
        type: "model.WorkRequestCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Restore the opensearch cluster details.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param OpensearchClusterRestoreRequest
   * @return OpensearchClusterRestoreResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/OpensearchClusterRestore.ts.html |here} to see how to use OpensearchClusterRestore API.
   */
  public async opensearchClusterRestore(
    opensearchClusterRestoreRequest: requests.OpensearchClusterRestoreRequest
  ): Promise<responses.OpensearchClusterRestoreResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#opensearchClusterRestore.");
    const operationName = "opensearchClusterRestore";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": opensearchClusterRestoreRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": opensearchClusterRestoreRequest.ifMatch,
      "opc-retry-token": opensearchClusterRestoreRequest.opcRetryToken,
      "opc-request-id": opensearchClusterRestoreRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      opensearchClusterRestoreRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/restore",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        opensearchClusterRestoreRequest.restoreOpensearchClusterDetails,
        "RestoreOpensearchClusterDetails",
        model.RestoreOpensearchClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.OpensearchClusterRestoreResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Resize the opensearch cluster horizontal details.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ResizeOpensearchClusterHorizontalRequest
   * @return ResizeOpensearchClusterHorizontalResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ResizeOpensearchClusterHorizontal.ts.html |here} to see how to use ResizeOpensearchClusterHorizontal API.
   */
  public async resizeOpensearchClusterHorizontal(
    resizeOpensearchClusterHorizontalRequest: requests.ResizeOpensearchClusterHorizontalRequest
  ): Promise<responses.ResizeOpensearchClusterHorizontalResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterClient#resizeOpensearchClusterHorizontal."
      );
    const operationName = "resizeOpensearchClusterHorizontal";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": resizeOpensearchClusterHorizontalRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": resizeOpensearchClusterHorizontalRequest.ifMatch,
      "opc-retry-token": resizeOpensearchClusterHorizontalRequest.opcRetryToken,
      "opc-request-id": resizeOpensearchClusterHorizontalRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      resizeOpensearchClusterHorizontalRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/resizeHorizontal",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        resizeOpensearchClusterHorizontalRequest.resizeOpensearchClusterHorizontalDetails,
        "ResizeOpensearchClusterHorizontalDetails",
        model.ResizeOpensearchClusterHorizontalDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ResizeOpensearchClusterHorizontalResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Resize the opensearch cluster vertical details.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ResizeOpensearchClusterVerticalRequest
   * @return ResizeOpensearchClusterVerticalResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ResizeOpensearchClusterVertical.ts.html |here} to see how to use ResizeOpensearchClusterVertical API.
   */
  public async resizeOpensearchClusterVertical(
    resizeOpensearchClusterVerticalRequest: requests.ResizeOpensearchClusterVerticalRequest
  ): Promise<responses.ResizeOpensearchClusterVerticalResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterClient#resizeOpensearchClusterVertical."
      );
    const operationName = "resizeOpensearchClusterVertical";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": resizeOpensearchClusterVerticalRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": resizeOpensearchClusterVerticalRequest.ifMatch,
      "opc-retry-token": resizeOpensearchClusterVerticalRequest.opcRetryToken,
      "opc-request-id": resizeOpensearchClusterVerticalRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      resizeOpensearchClusterVerticalRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/resizeVertical",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        resizeOpensearchClusterVerticalRequest.resizeOpensearchClusterVerticalDetails,
        "ResizeOpensearchClusterVerticalDetails",
        model.ResizeOpensearchClusterVerticalDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ResizeOpensearchClusterVerticalResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the OpensearchCluster
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UpdateOpensearchClusterRequest
   * @return UpdateOpensearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/UpdateOpensearchCluster.ts.html |here} to see how to use UpdateOpensearchCluster API.
   */
  public async updateOpensearchCluster(
    updateOpensearchClusterRequest: requests.UpdateOpensearchClusterRequest
  ): Promise<responses.UpdateOpensearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#updateOpensearchCluster.");
    const operationName = "updateOpensearchCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": updateOpensearchClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateOpensearchClusterRequest.ifMatch,
      "opc-request-id": updateOpensearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateOpensearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateOpensearchClusterRequest.updateOpensearchClusterDetails,
        "UpdateOpensearchClusterDetails",
        model.UpdateOpensearchClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateOpensearchClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Upgrade or clone the opensearch cluster.
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UpgradeOpenSearchClusterRequest
   * @return UpgradeOpenSearchClusterResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/UpgradeOpenSearchCluster.ts.html |here} to see how to use UpgradeOpenSearchCluster API.
   */
  public async upgradeOpenSearchCluster(
    upgradeOpenSearchClusterRequest: requests.UpgradeOpenSearchClusterRequest
  ): Promise<responses.UpgradeOpenSearchClusterResponse> {
    if (this.logger)
      this.logger.debug("Calling operation OpensearchClusterClient#upgradeOpenSearchCluster.");
    const operationName = "upgradeOpenSearchCluster";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterId}": upgradeOpenSearchClusterRequest.opensearchClusterId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": upgradeOpenSearchClusterRequest.ifMatch,
      "opc-retry-token": upgradeOpenSearchClusterRequest.opcRetryToken,
      "opc-request-id": upgradeOpenSearchClusterRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      upgradeOpenSearchClusterRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusters/{opensearchClusterId}/actions/upgrade",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        upgradeOpenSearchClusterRequest.upgradeOpenSearchClusterDetails,
        "UpgradeOpenSearchClusterDetails",
        model.UpgradeOpenSearchClusterDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpgradeOpenSearchClusterResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum OpensearchClusterBackupApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class OpensearchClusterBackupClient {
  protected static serviceEndpointTemplate =
    "https://search-indexing.{region}.oci.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": OpensearchClusterBackupWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "OpensearchClusterBackup";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("opensearch")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("opensearch");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180828";
    if (this.logger)
      this.logger.info(`OpensearchClusterBackupClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        OpensearchClusterBackupClient.serviceEndpointTemplate,
        this._region,
        OpensearchClusterBackupClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        OpensearchClusterBackupClient.serviceEndpointTemplate,
        this._regionId,
        OpensearchClusterBackupClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      OpensearchClusterBackupClient.serviceEndpointTemplate,
      region,
      OpensearchClusterBackupClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      OpensearchClusterBackupClient.serviceEndpointTemplate,
      regionId,
      OpensearchClusterBackupClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new OpensearchClusterBackupWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): OpensearchClusterBackupWaiter {
    this._waiters = new OpensearchClusterBackupWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): OpensearchClusterBackupWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Deletes a OpensearchClusterBackup resource by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DeleteOpensearchClusterBackupRequest
   * @return DeleteOpensearchClusterBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/DeleteOpensearchClusterBackup.ts.html |here} to see how to use DeleteOpensearchClusterBackup API.
   */
  public async deleteOpensearchClusterBackup(
    deleteOpensearchClusterBackupRequest: requests.DeleteOpensearchClusterBackupRequest
  ): Promise<responses.DeleteOpensearchClusterBackupResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterBackupClient#deleteOpensearchClusterBackup."
      );
    const operationName = "deleteOpensearchClusterBackup";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterBackupId}": deleteOpensearchClusterBackupRequest.opensearchClusterBackupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteOpensearchClusterBackupRequest.ifMatch,
      "opc-request-id": deleteOpensearchClusterBackupRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteOpensearchClusterBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterBackups/{opensearchClusterBackupId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteOpensearchClusterBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a OpensearchClusterBackup by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetOpensearchClusterBackupRequest
   * @return GetOpensearchClusterBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/GetOpensearchClusterBackup.ts.html |here} to see how to use GetOpensearchClusterBackup API.
   */
  public async getOpensearchClusterBackup(
    getOpensearchClusterBackupRequest: requests.GetOpensearchClusterBackupRequest
  ): Promise<responses.GetOpensearchClusterBackupResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterBackupClient#getOpensearchClusterBackup."
      );
    const operationName = "getOpensearchClusterBackup";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterBackupId}": getOpensearchClusterBackupRequest.opensearchClusterBackupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getOpensearchClusterBackupRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getOpensearchClusterBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterBackups/{opensearchClusterBackupId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetOpensearchClusterBackupResponse>{},
        body: await response.json(),
        bodyKey: "opensearchClusterBackup",
        bodyModel: model.OpensearchClusterBackup,
        type: "model.OpensearchClusterBackup",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of OpensearchClusterBackups.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListOpensearchClusterBackupsRequest
   * @return ListOpensearchClusterBackupsResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListOpensearchClusterBackups.ts.html |here} to see how to use ListOpensearchClusterBackups API.
   */
  public async listOpensearchClusterBackups(
    listOpensearchClusterBackupsRequest: requests.ListOpensearchClusterBackupsRequest
  ): Promise<responses.ListOpensearchClusterBackupsResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterBackupClient#listOpensearchClusterBackups."
      );
    const operationName = "listOpensearchClusterBackups";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listOpensearchClusterBackupsRequest.compartmentId,
      "lifecycleState": listOpensearchClusterBackupsRequest.lifecycleState,
      "displayName": listOpensearchClusterBackupsRequest.displayName,
      "sourceOpensearchClusterId": listOpensearchClusterBackupsRequest.sourceOpensearchClusterId,
      "id": listOpensearchClusterBackupsRequest.id,
      "limit": listOpensearchClusterBackupsRequest.limit,
      "page": listOpensearchClusterBackupsRequest.page,
      "sortOrder": listOpensearchClusterBackupsRequest.sortOrder,
      "sortBy": listOpensearchClusterBackupsRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listOpensearchClusterBackupsRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listOpensearchClusterBackupsRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterBackups",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOpensearchClusterBackupsResponse>{},
        body: await response.json(),
        bodyKey: "opensearchClusterBackupCollection",
        bodyModel: model.OpensearchClusterBackupCollection,
        type: "model.OpensearchClusterBackupCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the OpensearchClusterBackup
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UpdateOpensearchClusterBackupRequest
   * @return UpdateOpensearchClusterBackupResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/UpdateOpensearchClusterBackup.ts.html |here} to see how to use UpdateOpensearchClusterBackup API.
   */
  public async updateOpensearchClusterBackup(
    updateOpensearchClusterBackupRequest: requests.UpdateOpensearchClusterBackupRequest
  ): Promise<responses.UpdateOpensearchClusterBackupResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterBackupClient#updateOpensearchClusterBackup."
      );
    const operationName = "updateOpensearchClusterBackup";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterBackupId}": updateOpensearchClusterBackupRequest.opensearchClusterBackupId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateOpensearchClusterBackupRequest.ifMatch,
      "opc-request-id": updateOpensearchClusterBackupRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateOpensearchClusterBackupRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterBackups/{opensearchClusterBackupId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateOpensearchClusterBackupRequest.updateOpensearchClusterBackupDetails,
        "UpdateOpensearchClusterBackupDetails",
        model.UpdateOpensearchClusterBackupDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateOpensearchClusterBackupResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
export enum OpensearchClusterPipelineApiKeys {}
/**
 * This service client uses {@link common.CircuitBreaker.DefaultConfiguration} for all the operations by default if no circuit breaker configuration is defined by the user.
 */
export class OpensearchClusterPipelineClient {
  protected static serviceEndpointTemplate =
    "https://search-indexing.{region}.oci.{secondLevelDomain}";
  protected static endpointServiceName = "";
  protected "_realmSpecificEndpointTemplateEnabled": boolean | undefined = undefined;
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": OpensearchClusterPipelineWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;
  protected _circuitBreaker: typeof Breaker | null = null;
  protected _httpOptions: any = undefined;
  protected _bodyDuplexMode: any = undefined;
  public targetService = "OpensearchClusterPipeline";
  protected _regionId: string = "";
  protected "_region": common.Region;
  protected _lastSetRegionOrRegionId: string = "";

  protected _httpClient: common.HttpClient;
  protected _authProvider: common.AuthenticationDetailsProvider | undefined;

  constructor(params: common.AuthParams, clientConfiguration?: common.ClientConfiguration) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._authProvider = params.authenticationDetailsProvider;
    if (clientConfiguration) {
      this._clientConfiguration = clientConfiguration;
      this._circuitBreaker = clientConfiguration.circuitBreaker
        ? clientConfiguration.circuitBreaker!.circuit
        : null;
      this._httpOptions = clientConfiguration.httpOptions
        ? clientConfiguration.httpOptions
        : undefined;
      this._bodyDuplexMode = clientConfiguration.bodyDuplexMode
        ? clientConfiguration.bodyDuplexMode
        : undefined;
    }

    if (!developerToolConfiguration.isServiceEnabled("opensearch")) {
      let errmsg =
        "The developerToolConfiguration configuration disabled this service, this behavior is controlled by developerToolConfiguration.ociEnabledServiceSet variable. Please check if your local developer_tool_configuration file has configured the service you're targeting or contact the cloud provider on the availability of this service : ";
      throw errmsg.concat("opensearch");
    }

    // if circuit breaker is not created, check if circuit breaker system is enabled to use default circuit breaker
    const specCircuitBreakerEnabled = true;
    if (
      !this._circuitBreaker &&
      common.utils.isCircuitBreakerSystemEnabled(clientConfiguration!) &&
      (specCircuitBreakerEnabled || common.CircuitBreaker.DefaultCircuitBreakerOverriden)
    ) {
      this._circuitBreaker = new common.CircuitBreaker().circuit;
    }
    this._httpClient =
      params.httpClient ||
      new common.FetchHttpClient(
        requestSigner,
        this._circuitBreaker,
        this._httpOptions,
        this._bodyDuplexMode
      );

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180828";
    if (this.logger)
      this.logger.info(`OpensearchClusterPipelineClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Determines whether realm specific endpoint should be used or not.
   * Set realmSpecificEndpointTemplateEnabled to "true" if the user wants to enable use of realm specific endpoint template, otherwise set it to "false"
   * @param realmSpecificEndpointTemplateEnabled flag to enable the use of realm specific endpoint template
   */
  public set useRealmSpecificEndpointTemplate(realmSpecificEndpointTemplateEnabled: boolean) {
    this._realmSpecificEndpointTemplateEnabled = realmSpecificEndpointTemplateEnabled;
    if (this.logger)
      this.logger.info(
        `realmSpecificEndpointTemplateEnabled set to ${this._realmSpecificEndpointTemplateEnabled}`
      );
    if (this._lastSetRegionOrRegionId === common.Region.REGION_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
        OpensearchClusterPipelineClient.serviceEndpointTemplate,
        this._region,
        OpensearchClusterPipelineClient.endpointServiceName
      );
    } else if (this._lastSetRegionOrRegionId === common.Region.REGION_ID_STRING) {
      this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
        OpensearchClusterPipelineClient.serviceEndpointTemplate,
        this._regionId,
        OpensearchClusterPipelineClient.endpointServiceName
      );
    }
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this._region = region;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      OpensearchClusterPipelineClient.serviceEndpointTemplate,
      region,
      OpensearchClusterPipelineClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_STRING;
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this._regionId = regionId;
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      OpensearchClusterPipelineClient.serviceEndpointTemplate,
      regionId,
      OpensearchClusterPipelineClient.endpointServiceName
    );
    this._lastSetRegionOrRegionId = common.Region.REGION_ID_STRING;
  }

  /**
   * Creates a new OpensearchClusterPipelineWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): OpensearchClusterPipelineWaiter {
    this._waiters = new OpensearchClusterPipelineWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): OpensearchClusterPipelineWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Shutdown the circuit breaker used by the client when it is no longer needed
   */
  public shutdownCircuitBreaker() {
    if (this._circuitBreaker) {
      this._circuitBreaker.shutdown();
    }
  }

  /**
   * Close the provider if possible which in turn shuts down any associated circuit breaker
   */
  public closeProvider() {
    if (this._authProvider) {
      if (this._authProvider instanceof common.AbstractRequestingAuthenticationDetailsProvider)
        (<common.AbstractRequestingAuthenticationDetailsProvider>(
          this._authProvider
        )).closeProvider();
    }
  }

  /**
   * Close the client once it is no longer needed
   */
  public close() {
    this.shutdownCircuitBreaker();
    this.closeProvider();
  }

  /**
   * Creates a new OpensearchCluster Pipeline.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param CreateOpensearchClusterPipelineRequest
   * @return CreateOpensearchClusterPipelineResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/CreateOpensearchClusterPipeline.ts.html |here} to see how to use CreateOpensearchClusterPipeline API.
   */
  public async createOpensearchClusterPipeline(
    createOpensearchClusterPipelineRequest: requests.CreateOpensearchClusterPipelineRequest
  ): Promise<responses.CreateOpensearchClusterPipelineResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterPipelineClient#createOpensearchClusterPipeline."
      );
    const operationName = "createOpensearchClusterPipeline";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-retry-token": createOpensearchClusterPipelineRequest.opcRetryToken,
      "opc-request-id": createOpensearchClusterPipelineRequest.opcRequestId,
      "opc-dry-run": createOpensearchClusterPipelineRequest.opcDryRun
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      createOpensearchClusterPipelineRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterPipelines",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createOpensearchClusterPipelineRequest.createOpensearchClusterPipelineDetails,
        "CreateOpensearchClusterPipelineDetails",
        model.CreateOpensearchClusterPipelineDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateOpensearchClusterPipelineResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes a OpensearchCluster Pipeline resource by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param DeleteOpensearchClusterPipelineRequest
   * @return DeleteOpensearchClusterPipelineResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/DeleteOpensearchClusterPipeline.ts.html |here} to see how to use DeleteOpensearchClusterPipeline API.
   */
  public async deleteOpensearchClusterPipeline(
    deleteOpensearchClusterPipelineRequest: requests.DeleteOpensearchClusterPipelineRequest
  ): Promise<responses.DeleteOpensearchClusterPipelineResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterPipelineClient#deleteOpensearchClusterPipeline."
      );
    const operationName = "deleteOpensearchClusterPipeline";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterPipelineId}":
        deleteOpensearchClusterPipelineRequest.opensearchClusterPipelineId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": deleteOpensearchClusterPipelineRequest.ifMatch,
      "opc-request-id": deleteOpensearchClusterPipelineRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      deleteOpensearchClusterPipelineRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterPipelines/{opensearchClusterPipelineId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteOpensearchClusterPipelineResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a OpensearchCluster Pipeline by identifier
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param GetOpensearchClusterPipelineRequest
   * @return GetOpensearchClusterPipelineResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/GetOpensearchClusterPipeline.ts.html |here} to see how to use GetOpensearchClusterPipeline API.
   */
  public async getOpensearchClusterPipeline(
    getOpensearchClusterPipelineRequest: requests.GetOpensearchClusterPipelineRequest
  ): Promise<responses.GetOpensearchClusterPipelineResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterPipelineClient#getOpensearchClusterPipeline."
      );
    const operationName = "getOpensearchClusterPipeline";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterPipelineId}":
        getOpensearchClusterPipelineRequest.opensearchClusterPipelineId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": getOpensearchClusterPipelineRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      getOpensearchClusterPipelineRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterPipelines/{opensearchClusterPipelineId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.GetOpensearchClusterPipelineResponse>{},
        body: await response.json(),
        bodyKey: "opensearchClusterPipeline",
        bodyModel: model.OpensearchClusterPipeline,
        type: "model.OpensearchClusterPipeline",
        responseHeaders: [
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Returns a list of OpensearchClusterPipelines.
   *
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param ListOpensearchClusterPipelinesRequest
   * @return ListOpensearchClusterPipelinesResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/ListOpensearchClusterPipelines.ts.html |here} to see how to use ListOpensearchClusterPipelines API.
   */
  public async listOpensearchClusterPipelines(
    listOpensearchClusterPipelinesRequest: requests.ListOpensearchClusterPipelinesRequest
  ): Promise<responses.ListOpensearchClusterPipelinesResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterPipelineClient#listOpensearchClusterPipelines."
      );
    const operationName = "listOpensearchClusterPipelines";
    const apiReferenceLink = "";
    const pathParams = {};

    const queryParams = {
      "compartmentId": listOpensearchClusterPipelinesRequest.compartmentId,
      "lifecycleState": listOpensearchClusterPipelinesRequest.lifecycleState,
      "pipelineComponentId": listOpensearchClusterPipelinesRequest.pipelineComponentId,
      "displayName": listOpensearchClusterPipelinesRequest.displayName,
      "id": listOpensearchClusterPipelinesRequest.id,
      "limit": listOpensearchClusterPipelinesRequest.limit,
      "page": listOpensearchClusterPipelinesRequest.page,
      "sortOrder": listOpensearchClusterPipelinesRequest.sortOrder,
      "sortBy": listOpensearchClusterPipelinesRequest.sortBy
    };

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "opc-request-id": listOpensearchClusterPipelinesRequest.opcRequestId
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      listOpensearchClusterPipelinesRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterPipelines",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.ListOpensearchClusterPipelinesResponse>{},
        body: await response.json(),
        bodyKey: "opensearchClusterPipelineCollection",
        bodyModel: model.OpensearchClusterPipelineCollection,
        type: "model.OpensearchClusterPipelineCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the OpensearchCluster Pipeline
   * This operation does not retry by default if the user has not defined a retry configuration.
   * @param UpdateOpensearchClusterPipelineRequest
   * @return UpdateOpensearchClusterPipelineResponse
   * @throws OciError when an error occurs
   * @example Click {@link https://docs.oracle.com/en-us/iaas/tools/typescript-sdk-examples/latest/opensearch/UpdateOpensearchClusterPipeline.ts.html |here} to see how to use UpdateOpensearchClusterPipeline API.
   */
  public async updateOpensearchClusterPipeline(
    updateOpensearchClusterPipelineRequest: requests.UpdateOpensearchClusterPipelineRequest
  ): Promise<responses.UpdateOpensearchClusterPipelineResponse> {
    if (this.logger)
      this.logger.debug(
        "Calling operation OpensearchClusterPipelineClient#updateOpensearchClusterPipeline."
      );
    const operationName = "updateOpensearchClusterPipeline";
    const apiReferenceLink = "";
    const pathParams = {
      "{opensearchClusterPipelineId}":
        updateOpensearchClusterPipelineRequest.opensearchClusterPipelineId
    };

    const queryParams = {};

    let headerParams = {
      "Content-Type": common.Constants.APPLICATION_JSON,
      "if-match": updateOpensearchClusterPipelineRequest.ifMatch,
      "opc-request-id": updateOpensearchClusterPipelineRequest.opcRequestId,
      "opc-dry-run": updateOpensearchClusterPipelineRequest.opcDryRun
    };

    const specRetryConfiguration = common.NoRetryConfigurationDetails;
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : undefined,
      updateOpensearchClusterPipelineRequest.retryConfiguration,
      specRetryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/opensearchClusterPipelines/{opensearchClusterPipelineId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateOpensearchClusterPipelineRequest.updateOpensearchClusterPipelineDetails,
        "UpdateOpensearchClusterPipelineDetails",
        model.UpdateOpensearchClusterPipelineDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    try {
      const response = await retrier.makeServiceCall(
        this._httpClient,
        request,
        this.targetService,
        operationName,
        apiReferenceLink
      );
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateOpensearchClusterPipelineResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
