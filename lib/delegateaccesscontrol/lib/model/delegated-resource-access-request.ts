/**
 * Oracle Delegate Access Control API
 * Oracle Delegate Access Control allows ExaCC and ExaCS customers to delegate management of their Exadata resources operators outside their tenancies. 
With Delegate Access Control, Support Providers can deliver managed services using comprehensive and robust tooling built on the OCI platform. 
Customers maintain control over who has access to the delegated resources in their tenancy and what actions can be taken. 
Enterprises managing resources across multiple tenants can use Delegate Access Control to streamline management tasks.
Using logging service, customers can view a near real-time audit report of all actions performed by a Service Provider operator. 

 * OpenAPI spec version: 20230801
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2024, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import * as model from "../model";
import common = require("oci-common");

/**
* A support operator raises Delegated Resource Access Request when they need access to any infrastructure resource governed by Delegation Control.
* The Delegated Resource Access Request identifies the target resource and the set of Service Provider Actions. Delegated Resource Access Request handling depends upon the Delegation Control 
* that governs the target resource, and the set of Service Provider Actions listed for approval in the Delegated Resource Access Request. If all of the Service Provider Actions 
* listed in the Delegated Resource Access Request are in the pre-approved list in the Delegation Control that governs the target resource, then the Delegated Resource Access Request is 
* automatically approved. If not, then the Delegated Resource Access Request requires explicit approval from the approver group specified by the Delegation Control governing the target resource.
* <p>
You can approve or reject a Delegated Resource Access Request. You can also revoke the approval of an already approved Delegated Resource Access Request. While creating a Delegated Resource Access Request, 
* the support operator specifies the duration of access. You have the option to approve the entire duration or reduce or even increase the time duration. 
* A support operator can also request for an extension. The approval for such an extension is processed the same way the original Delegated Resource Access Request was processed.
* 
*/
export interface DelegatedResourceAccessRequest {
  /**
   * The OCID of the Delegated Resource Access Request.
   */
  "id": string;
  /**
   * The OCID of the compartment that contains the Delegated Resource Access Request.
   */
  "compartmentId": string;
  /**
   * Display name. This is generated by the system automatically.
   */
  "displayName"?: string;
  /**
   * A list of ticket numbers related to this Delegated Resource Access Request, e.g. Service Request (SR) number and JIRA ticket number.
   */
  "ticketNumbers"?: Array<string>;
  /**
   * A short description explaining why this Delegated Resource Access Request is needed by the support operator.
   */
  "reasonForRequest": string;
  /**
   * Detailed description of this Delegated Resource Access Request.
   */
  "description": string;
  /**
   * Requested access start time in UTC.
   */
  "timeAccessRequested"?: Date;
  /**
   * The OCID of the target resource associated with the Delegated Resource Access Request. The support operator raises a Delegated Resource Access Request to get approval to
   * access the target resource.
   *
   */
  "resourceId": string;
  /**
   * The name of the target resource associated with the Delegated Resource Access Request. The support operator raises a Delegated Resource Access Request to get approval to
   * access the target resource.
   *
   */
  "resourceName"?: string;
  /**
   * Resource type for which the associated Delegation Control is applicable to.
   */
  "resourceType"?: model.DelegationControlResourceType;
  /**
   * Requester type
   */
  "requesterType"?: model.DelegatedResourceAccessRequesterType;
  /**
   * List of Service Provider Action names for which approval is sought by the support operator user. The list of pre-defined Service Provider Actions can be obtained from the ListServiceProviderActions API.
   */
  "requestedActionNames"?: Array<string>;
  /**
   * List of Database unique names for which access is requested. This parameter is required for DLGT_MGMT_SYS_MAINT_ACCESS cage when database access in needed.
   */
  "databaseNameList"?: Array<string>;
  /**
   * List of Service Provider Service Types being provided by the support operator user.
   */
  "providedServiceTypes"?: Array<DelegatedResourceAccessRequest.ProvidedServiceTypes>;
  /**
   * List of Delegation Subscription OCID that are associated with this Delegated Resource Access Request based on the service types being requested.
   */
  "delegationSubscriptionIds"?: Array<string>;
  /**
   * Priority assigned to the Delegated Resource Access Request by the support operator
   */
  "severity"?: model.DelegatedResourceAccessRequestSeverity;
  /**
   * Duration in hours for which access is sought on the target resource. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "durationInHours"?: number;
  /**
   * Duration in hours for which extension access is sought on the target resource. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "extendDurationInHours"?: number;
  /**
   * Set to true if the request is approved automatically based on preApprovedServiceProviderActionNames or isAutoApproveDuringMaintenance in the associated Delegation Control.
   */
  "isAutoApproved"?: boolean;
  /**
   * The current lifecycle state of the Delegated Resource Access Request.
   */
  "lifecycleState"?: DelegatedResourceAccessRequest.LifecycleState;
  /**
   * Description of the current lifecycle state in more detail.
   */
  "lifecycleStateDetails"?: string;
  /**
   * The current status of the Delegated Resource Access Request.
   */
  "requestStatus"?: model.DelegatedResourceAccessRequestStatus;
  /**
   * Time when the Delegated Resource Access Request was created in [RFC 3339](https://tools.ietf.org/html/rfc3339)timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
   *
   */
  "timeCreated"?: Date;
  /**
   * Time when the Delegated Resource Access Request was last modified in [RFC 3339](https://tools.ietf.org/html/rfc3339)timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
   *
   */
  "timeUpdated"?: Date;
  /**
   * Number of initial approvals that have been obtained so far. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "numInitialApprovals"?: number;
  /**
   * Number of extension approvals that have been obtained so far. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "numExtensionApprovals"?: number;
  /**
   * In case of single approval, this will have only one item. Else, a list of approvals.
   */
  "approvalInfo"?: Array<model.DelegatedResourceAccessRequestApprovalDetails>;
  /**
   * The comment entered by the support operator while closing the request.
   */
  "closureComment"?: string;
  /**
   * The OCID of the Delegation Control governing the target resource.
   */
  "delegationControlId"?: string;
  /**
   * Specifies the type of auditing to be enabled. There are two levels of auditing: command-level and keystroke-level.
   * By default, both command-level and keystroke-level auditing are enabled, i.e. commands and key strokes issued by the support operator are logged.
   *
   */
  "auditTypes"?: Array<DelegatedResourceAccessRequest.AuditTypes>;
  /**
   * Indicates if the delegated resource access request is waiting on more information from the operator
   */
  "isPendingMoreInfo"?: boolean;
  /**
    * Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace.
* For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
* <p>
Example: {@code {\"Department\": \"Finance\"}}
* 
    */
  "freeformTags"?: { [key: string]: string };
  /**
    * Defined tags for this resource. Each key is predefined and scoped to a namespace.
* For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
* <p>
Example: {@code {\"Operations\": {\"CostCenter\": \"42\"}}}
* 
    */
  "definedTags"?: { [key: string]: { [key: string]: any } };
  /**
    * System tags for this resource. Each key is predefined and scoped to a namespace.
* <p>
Example: {@code {\"orcl-cloud\": {\"free-tier-retained\": \"true\"}}}
* 
    */
  "systemTags"?: { [key: string]: { [key: string]: any } };
}

export namespace DelegatedResourceAccessRequest {
  export enum ProvidedServiceTypes {
    Troubleshooting = "TROUBLESHOOTING",
    AssistedPatching = "ASSISTED_PATCHING",
    /**
     * This value is used if a service returns a value for this enum that is not recognized by this
     * version of the SDK.
     */
    UnknownValue = "UNKNOWN_VALUE"
  }

  export enum LifecycleState {
    Accepted = "ACCEPTED",
    InProgress = "IN_PROGRESS",
    Waiting = "WAITING",
    Failed = "FAILED",
    Succeeded = "SUCCEEDED",
    Canceling = "CANCELING",
    Canceled = "CANCELED",
    NeedsAttention = "NEEDS_ATTENTION",
    /**
     * This value is used if a service returns a value for this enum that is not recognized by this
     * version of the SDK.
     */
    UnknownValue = "UNKNOWN_VALUE"
  }

  export enum AuditTypes {
    CommandAudit = "COMMAND_AUDIT",
    CommandKeystrokeAudit = "COMMAND_KEYSTROKE_AUDIT",
    /**
     * This value is used if a service returns a value for this enum that is not recognized by this
     * version of the SDK.
     */
    UnknownValue = "UNKNOWN_VALUE"
  }

  export function getJsonObj(obj: DelegatedResourceAccessRequest): object {
    const jsonObj = {
      ...obj,
      ...{
        "approvalInfo": obj.approvalInfo
          ? obj.approvalInfo.map(item => {
              return model.DelegatedResourceAccessRequestApprovalDetails.getJsonObj(item);
            })
          : undefined
      }
    };

    return jsonObj;
  }
  export function getDeserializedJsonObj(obj: DelegatedResourceAccessRequest): object {
    const jsonObj = {
      ...obj,
      ...{
        "approvalInfo": obj.approvalInfo
          ? obj.approvalInfo.map(item => {
              return model.DelegatedResourceAccessRequestApprovalDetails.getDeserializedJsonObj(
                item
              );
            })
          : undefined
      }
    };

    return jsonObj;
  }
}
