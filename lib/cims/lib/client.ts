/**
 * Support Management API
 * Use the Support Management API to manage support requests. For more information, see [Getting Help and Contacting Support](/iaas/Content/GSG/Tasks/contactingsupport.htm). **Note**: Before you can create service requests with this API, you need to have an Oracle Single Sign On (SSO) account, and you need to register your Customer Support Identifier (CSI) with My Oracle Support.
 * OpenAPI spec version: 20181231
 * Contact: oci_ops_cims_dev_us_grp@oracle.com
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import { paginateRecords, paginateResponses } from "oci-common";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum IncidentApiKeys {}

export class IncidentClient {
  protected static serviceEndpointTemplate =
    "https://incidentmanagement.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20181231";
    if (this.logger) this.logger.info(`IncidentClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      IncidentClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      IncidentClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * This API enables the customer to Create an Incident
   * @param CreateIncidentRequest
   * @return CreateIncidentResponse
   * @throws OciError when an error occurs
   */
  public async createIncident(
    createIncidentRequest: requests.CreateIncidentRequest
  ): Promise<responses.CreateIncidentResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#createIncident.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createIncidentRequest.opcRetryToken,
      "opc-request-id": createIncidentRequest.opcRequestId,
      "ocid": createIncidentRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createIncidentRequest.createIncidentDetails,
        "CreateIncident",
        models.CreateIncident.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createIncidentRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateIncidentResponse>{},
        body: await response.json(),
        bodyKey: "incident",
        bodyModel: "model.Incident",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * This API fetches the details of a requested Incident
   * @param GetIncidentRequest
   * @return GetIncidentResponse
   * @throws OciError when an error occurs
   */
  public async getIncident(
    getIncidentRequest: requests.GetIncidentRequest
  ): Promise<responses.GetIncidentResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#getIncident.");
    const pathParams = {
      "{incidentKey}": getIncidentRequest.incidentKey
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getIncidentRequest.opcRequestId,
      "csi": getIncidentRequest.csi,
      "ocid": getIncidentRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents/{incidentKey}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getIncidentRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetIncidentResponse>{},
        body: await response.json(),
        bodyKey: "incident",
        bodyModel: "model.Incident",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * GetStatus of the Service
   * @param GetStatusRequest
   * @return GetStatusResponse
   * @throws OciError when an error occurs
   */
  public async getStatus(
    getStatusRequest: requests.GetStatusRequest
  ): Promise<responses.GetStatusResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#getStatus.");
    const pathParams = {
      "{source}": getStatusRequest.source
    };

    const queryParams = {};

    let headerParams = {
      "opc-request-id": getStatusRequest.opcRequestId,
      "ocid": getStatusRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents/status/{source}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getStatusRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.GetStatusResponse>{},
        body: await response.json(),
        bodyKey: "status",
        bodyModel: "model.Status",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * This API returns the list of all possible product that OCI supports, while creating an incident
   * @param ListIncidentResourceTypesRequest
   * @return ListIncidentResourceTypesResponse
   * @throws OciError when an error occurs
   */
  public async listIncidentResourceTypes(
    listIncidentResourceTypesRequest: requests.ListIncidentResourceTypesRequest
  ): Promise<responses.ListIncidentResourceTypesResponse> {
    if (this.logger)
      this.logger.debug("Calling operation IncidentClient#listIncidentResourceTypes.");
    const pathParams = {};

    const queryParams = {
      "problemType": listIncidentResourceTypesRequest.problemType,
      "limit": listIncidentResourceTypesRequest.limit,
      "page": listIncidentResourceTypesRequest.page,
      "sortBy": listIncidentResourceTypesRequest.sortBy,
      "sortOrder": listIncidentResourceTypesRequest.sortOrder,
      "compartmentId": listIncidentResourceTypesRequest.compartmentId,
      "name": listIncidentResourceTypesRequest.name
    };

    let headerParams = {
      "opc-request-id": listIncidentResourceTypesRequest.opcRequestId,
      "csi": listIncidentResourceTypesRequest.csi,
      "ocid": listIncidentResourceTypesRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents/incidentResourceTypes",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listIncidentResourceTypesRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIncidentResourceTypesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IncidentResourceType[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IncidentResourceType objects
   * contained in responses from the listIncidentResourceTypes operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIncidentResourceTypes(
    request: requests.ListIncidentResourceTypesRequest
  ): AsyncIterableIterator<models.IncidentResourceType> {
    return paginateRecords(request, req => this.listIncidentResourceTypes(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIncidentResourceTypes operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIncidentResourceTypesResponses(
    request: requests.ListIncidentResourceTypesRequest
  ): AsyncIterableIterator<responses.ListIncidentResourceTypesResponse> {
    return paginateResponses(request, req => this.listIncidentResourceTypes(req));
  }

  /**
   * This API returns the list of incidents raised by the tenant
   * @param ListIncidentsRequest
   * @return ListIncidentsResponse
   * @throws OciError when an error occurs
   */
  public async listIncidents(
    listIncidentsRequest: requests.ListIncidentsRequest
  ): Promise<responses.ListIncidentsResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#listIncidents.");
    const pathParams = {};

    const queryParams = {
      "limit": listIncidentsRequest.limit,
      "compartmentId": listIncidentsRequest.compartmentId,
      "sortBy": listIncidentsRequest.sortBy,
      "sortOrder": listIncidentsRequest.sortOrder,
      "lifecycleState": listIncidentsRequest.lifecycleState,
      "page": listIncidentsRequest.page
    };

    let headerParams = {
      "csi": listIncidentsRequest.csi,
      "opc-request-id": listIncidentsRequest.opcRequestId,
      "ocid": listIncidentsRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listIncidentsRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ListIncidentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "IncidentSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.IncidentSummary objects
   * contained in responses from the listIncidents operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIncidents(
    request: requests.ListIncidentsRequest
  ): AsyncIterableIterator<models.IncidentSummary> {
    return paginateRecords(request, req => this.listIncidents(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listIncidents operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllIncidentsResponses(
    request: requests.ListIncidentsRequest
  ): AsyncIterableIterator<responses.ListIncidentsResponse> {
    return paginateResponses(request, req => this.listIncidents(req));
  }

  /**
   * This API updates an existing incident
   * @param UpdateIncidentRequest
   * @return UpdateIncidentResponse
   * @throws OciError when an error occurs
   */
  public async updateIncident(
    updateIncidentRequest: requests.UpdateIncidentRequest
  ): Promise<responses.UpdateIncidentResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#updateIncident.");
    const pathParams = {
      "{incidentKey}": updateIncidentRequest.incidentKey
    };

    const queryParams = {};

    let headerParams = {
      "csi": updateIncidentRequest.csi,
      "opc-retry-token": updateIncidentRequest.opcRetryToken,
      "opc-request-id": updateIncidentRequest.opcRequestId,
      "if-match": updateIncidentRequest.ifMatch,
      "ocid": updateIncidentRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents/{incidentKey}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateIncidentRequest.updateIncidentDetails,
        "UpdateIncident",
        models.UpdateIncident.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateIncidentRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateIncidentResponse>{},
        body: await response.json(),
        bodyKey: "incident",
        bodyModel: "model.Incident",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }

  /**
   * ValidateUser
   * @param ValidateUserRequest
   * @return ValidateUserResponse
   * @throws OciError when an error occurs
   */
  public async validateUser(
    validateUserRequest: requests.ValidateUserRequest
  ): Promise<responses.ValidateUserResponse> {
    if (this.logger) this.logger.debug("Calling operation IncidentClient#validateUser.");
    const pathParams = {};

    const queryParams = {
      "problemType": validateUserRequest.problemType
    };

    let headerParams = {
      "csi": validateUserRequest.csi,
      "opc-retry-token": validateUserRequest.opcRetryToken,
      "opc-request-id": validateUserRequest.opcRequestId,
      "ocid": validateUserRequest.ocid
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/v2/incidents/user/validate",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });

    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      validateUserRequest.retryConfiguration
    );
    const response = await retrier.makeServiceCall(() => this._httpClient.send(request));
    if (response.status && response.status >= 200 && response.status <= 299) {
      const sdkResponse = composeResponse({
        responseObject: <responses.ValidateUserResponse>{},
        body: await response.json(),
        bodyKey: "validationResponse",
        bodyModel: "model.ValidationResponse",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("etag"),
            key: "etag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } else {
      const errBody = await common.handleErrorBody(response);
      throw common.handleErrorResponse(response, errBody);
    }
  }
}
