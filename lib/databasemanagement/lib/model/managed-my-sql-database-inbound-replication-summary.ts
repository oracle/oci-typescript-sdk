/**
 * Database Management API
 * Use the Database Management API to monitor and manage resources such as
Oracle Databases, MySQL Databases, and External Database Systems. 
For more information, see [Database Management](https://docs.oracle.com/iaas/database-management/home.htm).

 * OpenAPI spec version: 20201101
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, 2025, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import * as model from "../model";
import common = require("oci-common");

/**
 * Inbound replication information of a MySQL replica.
 */
export interface ManagedMySqlDatabaseInboundReplicationSummary {
  /**
   * The host name or IP address of the source this replica is connected to.
   */
  "sourceHost": string;
  /**
   * The port used to connect to the source. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "sourcePort": number;
  /**
   * The current status of fetch operations.
   */
  "fetchStatus"?: string;
  /**
   * The current status of apply operations.
   */
  "applyStatus"?: string;
  /**
   * The desired number of seconds that the replica must lag the source. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "desiredDelaySeconds"?: number;
  /**
   * If the replica is waiting for the desired delay seconds to pass since the source applied an event, this field contains the number of delay seconds remaining. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "remainingDelaySeconds"?: number;
  /**
   * The name of the replication channel.
   */
  "channelName"?: string;
  /**
   * The Universally Unique Identifier (UUID) value from the source server.
   */
  "sourceUuid": string;
  /**
   * The server ID value from the source server. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "sourceServerId"?: number;
  /**
   * Indicates whether the channel assigns global transaction identifiers (GTIDs) to anonymous replicated transactions. OFF means no GTIDs are assigned. LOCAL means a GTID is assigned that includes this replica's own universally unique identifier (UUID). A UUID as value indicates that a GTID is assigned, which includes that manually set UUID value.
   */
  "gtidAssignment"?: string;
  /**
   * A list of MySqlReplicationApplierFilter records.
   */
  "applierFilters"?: Array<model.MySqlReplicationApplierFilter>;
  /**
   * The number of seconds the replica is behind the source server. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "secondsBehindSource"?: number;
  /**
   * The set of global transaction IDs corresponding to all transactions received by this replica from the source server. Empty if GTIDs are not in use.
   */
  "retrievedGtidSet"?: string;
  /**
   * The total size in bytes of all the existing relay log files pertaining to this channel. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "relayLogStorageSpaceUsed"?: number;
  /**
   * The number of transactions received by this replica from the source server. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "transactionsReceived"?: number;
  /**
   * The time in seconds that the current transaction took between being committed on the source and being applied on the replica. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "applyDelay"?: number;
  /**
   * The number of workers currently busy applying transactions from the source server. Note: Numbers greater than Number.MAX_SAFE_INTEGER will result in rounding issues.
   */
  "busyWorkers"?: number;
  "fetchError"?: model.MySqlFetchError;
  "applyError"?: model.MySqlApplyError;
}

export namespace ManagedMySqlDatabaseInboundReplicationSummary {
  export function getJsonObj(obj: ManagedMySqlDatabaseInboundReplicationSummary): object {
    const jsonObj = {
      ...obj,
      ...{
        "applierFilters": obj.applierFilters
          ? obj.applierFilters.map(item => {
              return model.MySqlReplicationApplierFilter.getJsonObj(item);
            })
          : undefined,

        "fetchError": obj.fetchError ? model.MySqlFetchError.getJsonObj(obj.fetchError) : undefined,
        "applyError": obj.applyError ? model.MySqlApplyError.getJsonObj(obj.applyError) : undefined
      }
    };

    return jsonObj;
  }
  export function getDeserializedJsonObj(
    obj: ManagedMySqlDatabaseInboundReplicationSummary
  ): object {
    const jsonObj = {
      ...obj,
      ...{
        "applierFilters": obj.applierFilters
          ? obj.applierFilters.map(item => {
              return model.MySqlReplicationApplierFilter.getDeserializedJsonObj(item);
            })
          : undefined,

        "fetchError": obj.fetchError
          ? model.MySqlFetchError.getDeserializedJsonObj(obj.fetchError)
          : undefined,
        "applyError": obj.applyError
          ? model.MySqlApplyError.getDeserializedJsonObj(obj.applyError)
          : undefined
      }
    };

    return jsonObj;
  }
}
