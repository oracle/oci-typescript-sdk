/**
 * DNS API
 * API for the DNS service. Use this API to manage DNS zones, records, and other DNS resources.
For more information, see [Overview of the DNS Service](/iaas/Content/DNS/Concepts/dnszonemanagement.htm).

 * OpenAPI spec version: 20180115
 * 
 *
 * NOTE: This class is auto generated by OracleSDKGenerator.
 * Do not edit the class manually.
 *
 * Copyright (c) 2020, Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */

import common = require("oci-common");
import * as requests from "./request";
import * as models from "./model";
import * as responses from "./response";
import {
  paginateRecords,
  paginateResponses,
  genericPaginateRecords,
  genericPaginateResponses
} from "oci-common";
import { DnsWaiter } from "./dns-waiter";
import { composeResponse, composeRequest, GenericRetrier } from "oci-common";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DnsApiKeys {}

export class DnsClient {
  protected static serviceEndpointTemplate = "https://dns.{region}.{secondLevelDomain}";
  protected "_endpoint": string = "";
  protected "_defaultHeaders": any = {};
  protected "_waiters": DnsWaiter;
  protected "_clientConfiguration": common.ClientConfiguration;

  protected _httpClient: common.HttpClient;

  constructor(params: common.AuthParams) {
    const requestSigner = params.authenticationDetailsProvider
      ? new common.DefaultRequestSigner(params.authenticationDetailsProvider)
      : null;
    this._httpClient = params.httpClient || new common.FetchHttpClient(requestSigner);

    if (
      params.authenticationDetailsProvider &&
      common.isRegionProvider(params.authenticationDetailsProvider)
    ) {
      const provider: common.RegionProvider = params.authenticationDetailsProvider;
      if (provider.getRegion()) {
        this.region = provider.getRegion();
      }
    }
  }

  /**
   * Get the endpoint that is being used to call (ex, https://www.example.com).
   */
  public get endpoint() {
    return this._endpoint;
  }

  /**
   * Sets the endpoint to call (ex, https://www.example.com).
   * @param endpoint The endpoint of the service.
   */
  public set endpoint(endpoint: string) {
    this._endpoint = endpoint;
    this._endpoint = this._endpoint + "/20180115";
    if (this.logger) this.logger.info(`DnsClient endpoint set to ${this._endpoint}`);
  }

  public get logger() {
    return common.LOG.logger;
  }

  /**
   * Sets the region to call (ex, Region.US_PHOENIX_1).
   * Note, this will call {@link #endpoint(String) endpoint} after resolving the endpoint.
   * @param region The region of the service.
   */
  public set region(region: common.Region) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegion(
      DnsClient.serviceEndpointTemplate,
      region
    );
  }

  /**
   * Sets the regionId to call (ex, 'us-phoenix-1').
   *
   * Note, this will first try to map the region ID to a known Region and call {@link #region(Region) region}.
   * If no known Region could be determined, it will create an endpoint assuming its in default Realm OC1
   * and then call {@link #endpoint(String) endpoint}.
   * @param regionId The public region ID.
   */
  public set regionId(regionId: string) {
    this.endpoint = common.EndpointBuilder.createEndpointFromRegionId(
      DnsClient.serviceEndpointTemplate,
      regionId
    );
  }

  /**
   * Creates a new DnsWaiter for resources for this service.
   *
   * @param config The waiter configuration for termination and delay strategy
   * @return The service waiters.
   */
  public createWaiters(config?: common.WaiterConfiguration): DnsWaiter {
    this._waiters = new DnsWaiter(this, config);
    return this._waiters;
  }

  /**
   * Gets the waiters available for resources for this service.
   *
   * @return The service waiters.
   */
  public getWaiters(): DnsWaiter {
    if (this._waiters) {
      return this._waiters;
    }
    throw Error("Waiters do not exist. Please create waiters.");
  }

  /**
   * Sets the client configuration for the client
   */
  public set clientConfiguration(clientConfiguration: common.ClientConfiguration) {
    this._clientConfiguration = clientConfiguration;
  }

  /**
   * Moves a steering policy into a different compartment.
   * @param ChangeSteeringPolicyCompartmentRequest
   * @return ChangeSteeringPolicyCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeSteeringPolicyCompartment(
    changeSteeringPolicyCompartmentRequest: requests.ChangeSteeringPolicyCompartmentRequest
  ): Promise<responses.ChangeSteeringPolicyCompartmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DnsClient#changeSteeringPolicyCompartment.");
    const pathParams = {
      "{steeringPolicyId}": changeSteeringPolicyCompartmentRequest.steeringPolicyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": changeSteeringPolicyCompartmentRequest.ifMatch,
      "opc-retry-token": changeSteeringPolicyCompartmentRequest.opcRetryToken,
      "opc-request-id": changeSteeringPolicyCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies/{steeringPolicyId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeSteeringPolicyCompartmentRequest.changeSteeringPolicyCompartmentDetails,
        "ChangeSteeringPolicyCompartmentDetails",
        models.ChangeSteeringPolicyCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeSteeringPolicyCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeSteeringPolicyCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a TSIG key into a different compartment.
   * @param ChangeTsigKeyCompartmentRequest
   * @return ChangeTsigKeyCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeTsigKeyCompartment(
    changeTsigKeyCompartmentRequest: requests.ChangeTsigKeyCompartmentRequest
  ): Promise<responses.ChangeTsigKeyCompartmentResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#changeTsigKeyCompartment.");
    const pathParams = {
      "{tsigKeyId}": changeTsigKeyCompartmentRequest.tsigKeyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": changeTsigKeyCompartmentRequest.ifMatch,
      "opc-retry-token": changeTsigKeyCompartmentRequest.opcRetryToken,
      "opc-request-id": changeTsigKeyCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys/{tsigKeyId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeTsigKeyCompartmentRequest.changeTsigKeyCompartmentDetails,
        "ChangeTsigKeyCompartmentDetails",
        models.ChangeTsigKeyCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeTsigKeyCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeTsigKeyCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Moves a zone into a different compartment.
   * **Note:** All SteeringPolicyAttachment objects associated with this zone will also be moved into the provided compartment.
   * @param ChangeZoneCompartmentRequest
   * @return ChangeZoneCompartmentResponse
   * @throws OciError when an error occurs
   */
  public async changeZoneCompartment(
    changeZoneCompartmentRequest: requests.ChangeZoneCompartmentRequest
  ): Promise<responses.ChangeZoneCompartmentResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#changeZoneCompartment.");
    const pathParams = {
      "{zoneId}": changeZoneCompartmentRequest.zoneId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": changeZoneCompartmentRequest.ifMatch,
      "opc-retry-token": changeZoneCompartmentRequest.opcRetryToken,
      "opc-request-id": changeZoneCompartmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneId}/actions/changeCompartment",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        changeZoneCompartmentRequest.changeZoneCompartmentDetails,
        "ChangeZoneCompartmentDetails",
        models.ChangeZoneCompartmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      changeZoneCompartmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ChangeZoneCompartmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new steering policy in the specified compartment. For more information on
   * creating policies with templates, see [Traffic Management API Guide](https://docs.cloud.oracle.com/iaas/Content/TrafficManagement/Concepts/trafficmanagementapi.htm).
   *
   * @param CreateSteeringPolicyRequest
   * @return CreateSteeringPolicyResponse
   * @throws OciError when an error occurs
   */
  public async createSteeringPolicy(
    createSteeringPolicyRequest: requests.CreateSteeringPolicyRequest
  ): Promise<responses.CreateSteeringPolicyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#createSteeringPolicy.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSteeringPolicyRequest.opcRetryToken,
      "opc-request-id": createSteeringPolicyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSteeringPolicyRequest.createSteeringPolicyDetails,
        "CreateSteeringPolicyDetails",
        models.CreateSteeringPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createSteeringPolicyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSteeringPolicyResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicy",
        bodyModel: "model.SteeringPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
     * Creates a new attachment between a steering policy and a domain, giving the
* policy permission to answer queries for the specified domain. A steering policy must
* be attached to a domain for the policy to answer DNS queries for that domain.
* <p>
For the purposes of access control, the attachment is automatically placed
* into the same compartment as the domain's zone.
* 
     * @param CreateSteeringPolicyAttachmentRequest
     * @return CreateSteeringPolicyAttachmentResponse
     * @throws OciError when an error occurs
     */
  public async createSteeringPolicyAttachment(
    createSteeringPolicyAttachmentRequest: requests.CreateSteeringPolicyAttachmentRequest
  ): Promise<responses.CreateSteeringPolicyAttachmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DnsClient#createSteeringPolicyAttachment.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-retry-token": createSteeringPolicyAttachmentRequest.opcRetryToken,
      "opc-request-id": createSteeringPolicyAttachmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicyAttachments",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createSteeringPolicyAttachmentRequest.createSteeringPolicyAttachmentDetails,
        "CreateSteeringPolicyAttachmentDetails",
        models.CreateSteeringPolicyAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createSteeringPolicyAttachmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateSteeringPolicyAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicyAttachment",
        bodyModel: "model.SteeringPolicyAttachment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new TSIG key in the specified compartment. There is no
   * `opc-retry-token` header since TSIG key names must be globally unique.
   *
   * @param CreateTsigKeyRequest
   * @return CreateTsigKeyResponse
   * @throws OciError when an error occurs
   */
  public async createTsigKey(
    createTsigKeyRequest: requests.CreateTsigKeyRequest
  ): Promise<responses.CreateTsigKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#createTsigKey.");
    const pathParams = {};

    const queryParams = {};

    let headerParams = {
      "opc-request-id": createTsigKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createTsigKeyRequest.createTsigKeyDetails,
        "CreateTsigKeyDetails",
        models.CreateTsigKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createTsigKeyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateTsigKeyResponse>{},
        body: await response.json(),
        bodyKey: "tsigKey",
        bodyModel: "model.TsigKey",
        responseHeaders: [
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new zone in the specified compartment. The `compartmentId`
   * query parameter is required if the `Content-Type` header for the
   * request is `text/dns`.
   *
   * @param CreateZoneRequest
   * @return CreateZoneResponse
   * @throws OciError when an error occurs
   */
  public async createZone(
    createZoneRequest: requests.CreateZoneRequest
  ): Promise<responses.CreateZoneResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#createZone.");
    const pathParams = {};

    const queryParams = {
      "compartmentId": createZoneRequest.compartmentId
    };

    let headerParams = {
      "opc-request-id": createZoneRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones",
      method: "POST",
      bodyContent: common.ObjectSerializer.serialize(
        createZoneRequest.createZoneDetails,
        "CreateZoneBaseDetails",
        models.CreateZoneBaseDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      createZoneRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.CreateZoneResponse>{},
        body: await response.json(),
        bodyKey: "zone",
        bodyModel: "model.Zone",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes all records at the specified zone and domain.
   * @param DeleteDomainRecordsRequest
   * @return DeleteDomainRecordsResponse
   * @throws OciError when an error occurs
   */
  public async deleteDomainRecords(
    deleteDomainRecordsRequest: requests.DeleteDomainRecordsRequest
  ): Promise<responses.DeleteDomainRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#deleteDomainRecords.");
    const pathParams = {
      "{zoneNameOrId}": deleteDomainRecordsRequest.zoneNameOrId,
      "{domain}": deleteDomainRecordsRequest.domain
    };

    const queryParams = {
      "compartmentId": deleteDomainRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-Match": deleteDomainRecordsRequest.ifMatch,
      "If-Unmodified-Since": deleteDomainRecordsRequest.ifUnmodifiedSince,
      "opc-request-id": deleteDomainRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteDomainRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteDomainRecordsResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes all records in the specified RRSet.
   *
   * @param DeleteRRSetRequest
   * @return DeleteRRSetResponse
   * @throws OciError when an error occurs
   */
  public async deleteRRSet(
    deleteRRSetRequest: requests.DeleteRRSetRequest
  ): Promise<responses.DeleteRRSetResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#deleteRRSet.");
    const pathParams = {
      "{zoneNameOrId}": deleteRRSetRequest.zoneNameOrId,
      "{domain}": deleteRRSetRequest.domain,
      "{rtype}": deleteRRSetRequest.rtype
    };

    const queryParams = {
      "compartmentId": deleteRRSetRequest.compartmentId
    };

    let headerParams = {
      "If-Match": deleteRRSetRequest.ifMatch,
      "If-Unmodified-Since": deleteRRSetRequest.ifUnmodifiedSince,
      "opc-request-id": deleteRRSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}/{rtype}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteRRSetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteRRSetResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified steering policy.
   * A `204` response indicates that the delete has been successful.
   * Deletion will fail if the policy is attached to any zones. To detach a
   * policy from a zone, see `DeleteSteeringPolicyAttachment`.
   *
   * @param DeleteSteeringPolicyRequest
   * @return DeleteSteeringPolicyResponse
   * @throws OciError when an error occurs
   */
  public async deleteSteeringPolicy(
    deleteSteeringPolicyRequest: requests.DeleteSteeringPolicyRequest
  ): Promise<responses.DeleteSteeringPolicyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#deleteSteeringPolicy.");
    const pathParams = {
      "{steeringPolicyId}": deleteSteeringPolicyRequest.steeringPolicyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": deleteSteeringPolicyRequest.ifMatch,
      "If-Unmodified-Since": deleteSteeringPolicyRequest.ifUnmodifiedSince,
      "opc-request-id": deleteSteeringPolicyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies/{steeringPolicyId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteSteeringPolicyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSteeringPolicyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified steering policy attachment.
   * A `204` response indicates that the delete has been successful.
   *
   * @param DeleteSteeringPolicyAttachmentRequest
   * @return DeleteSteeringPolicyAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async deleteSteeringPolicyAttachment(
    deleteSteeringPolicyAttachmentRequest: requests.DeleteSteeringPolicyAttachmentRequest
  ): Promise<responses.DeleteSteeringPolicyAttachmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DnsClient#deleteSteeringPolicyAttachment.");
    const pathParams = {
      "{steeringPolicyAttachmentId}":
        deleteSteeringPolicyAttachmentRequest.steeringPolicyAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": deleteSteeringPolicyAttachmentRequest.ifMatch,
      "If-Unmodified-Since": deleteSteeringPolicyAttachmentRequest.ifUnmodifiedSince,
      "opc-request-id": deleteSteeringPolicyAttachmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicyAttachments/{steeringPolicyAttachmentId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteSteeringPolicyAttachmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteSteeringPolicyAttachmentResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified TSIG key.
   *
   * @param DeleteTsigKeyRequest
   * @return DeleteTsigKeyResponse
   * @throws OciError when an error occurs
   */
  public async deleteTsigKey(
    deleteTsigKeyRequest: requests.DeleteTsigKeyRequest
  ): Promise<responses.DeleteTsigKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#deleteTsigKey.");
    const pathParams = {
      "{tsigKeyId}": deleteTsigKeyRequest.tsigKeyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": deleteTsigKeyRequest.ifMatch,
      "If-Unmodified-Since": deleteTsigKeyRequest.ifUnmodifiedSince,
      "opc-request-id": deleteTsigKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys/{tsigKeyId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteTsigKeyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteTsigKeyResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-work-request-id"),
            key: "opcWorkRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Deletes the specified zone and all its steering policy attachments.
   * A `204` response indicates that zone has been successfully deleted.
   *
   * @param DeleteZoneRequest
   * @return DeleteZoneResponse
   * @throws OciError when an error occurs
   */
  public async deleteZone(
    deleteZoneRequest: requests.DeleteZoneRequest
  ): Promise<responses.DeleteZoneResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#deleteZone.");
    const pathParams = {
      "{zoneNameOrId}": deleteZoneRequest.zoneNameOrId
    };

    const queryParams = {
      "compartmentId": deleteZoneRequest.compartmentId
    };

    let headerParams = {
      "If-Match": deleteZoneRequest.ifMatch,
      "If-Unmodified-Since": deleteZoneRequest.ifUnmodifiedSince,
      "opc-request-id": deleteZoneRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}",
      method: "DELETE",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      deleteZoneRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.DeleteZoneResponse>{},
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets a list of all records at the specified zone and domain.
   * The results are sorted by `rtype` in alphabetical order by default. You
   * can optionally filter and/or sort the results using the listed parameters.
   *
   * @param GetDomainRecordsRequest
   * @return GetDomainRecordsResponse
   * @throws OciError when an error occurs
   */
  public async getDomainRecords(
    getDomainRecordsRequest: requests.GetDomainRecordsRequest
  ): Promise<responses.GetDomainRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getDomainRecords.");
    const pathParams = {
      "{zoneNameOrId}": getDomainRecordsRequest.zoneNameOrId,
      "{domain}": getDomainRecordsRequest.domain
    };

    const queryParams = {
      "limit": getDomainRecordsRequest.limit,
      "page": getDomainRecordsRequest.page,
      "zoneVersion": getDomainRecordsRequest.zoneVersion,
      "rtype": getDomainRecordsRequest.rtype,
      "sortBy": getDomainRecordsRequest.sortBy,
      "sortOrder": getDomainRecordsRequest.sortOrder,
      "compartmentId": getDomainRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-None-Match": getDomainRecordsRequest.ifNoneMatch,
      "If-Modified-Since": getDomainRecordsRequest.ifModifiedSince,
      "opc-request-id": getDomainRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getDomainRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetDomainRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Record objects
   * contained in responses from the getDomainRecords operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllDomainRecords(
    request: requests.GetDomainRecordsRequest
  ): AsyncIterableIterator<models.Record> {
    return genericPaginateRecords(
      request,
      req => this.getDomainRecords(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken),
      res => res.recordCollection.items || []
    );
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the getDomainRecords operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllDomainRecordsResponses(
    request: requests.GetDomainRecordsRequest
  ): AsyncIterableIterator<responses.GetDomainRecordsResponse> {
    return genericPaginateResponses(
      request,
      req => this.getDomainRecords(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken)
    );
  }

  /**
   * Gets a list of all records in the specified RRSet. The results are
   * sorted by `recordHash` by default.
   *
   * @param GetRRSetRequest
   * @return GetRRSetResponse
   * @throws OciError when an error occurs
   */
  public async getRRSet(
    getRRSetRequest: requests.GetRRSetRequest
  ): Promise<responses.GetRRSetResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getRRSet.");
    const pathParams = {
      "{zoneNameOrId}": getRRSetRequest.zoneNameOrId,
      "{domain}": getRRSetRequest.domain,
      "{rtype}": getRRSetRequest.rtype
    };

    const queryParams = {
      "limit": getRRSetRequest.limit,
      "page": getRRSetRequest.page,
      "zoneVersion": getRRSetRequest.zoneVersion,
      "compartmentId": getRRSetRequest.compartmentId
    };

    let headerParams = {
      "If-None-Match": getRRSetRequest.ifNoneMatch,
      "If-Modified-Since": getRRSetRequest.ifModifiedSince,
      "opc-request-id": getRRSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}/{rtype}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getRRSetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetRRSetResponse>{},
        body: await response.json(),
        bodyKey: "rRSet",
        bodyModel: "model.RRSet",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Record objects
   * contained in responses from the getRRSet operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllRRSet(request: requests.GetRRSetRequest): AsyncIterableIterator<models.Record> {
    return genericPaginateRecords(
      request,
      req => this.getRRSet(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken),
      res => res.rRSet.items || []
    );
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the getRRSet operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllRRSetResponses(
    request: requests.GetRRSetRequest
  ): AsyncIterableIterator<responses.GetRRSetResponse> {
    return genericPaginateResponses(
      request,
      req => this.getRRSet(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken)
    );
  }

  /**
   * Gets information about the specified steering policy.
   *
   * @param GetSteeringPolicyRequest
   * @return GetSteeringPolicyResponse
   * @throws OciError when an error occurs
   */
  public async getSteeringPolicy(
    getSteeringPolicyRequest: requests.GetSteeringPolicyRequest
  ): Promise<responses.GetSteeringPolicyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getSteeringPolicy.");
    const pathParams = {
      "{steeringPolicyId}": getSteeringPolicyRequest.steeringPolicyId
    };

    const queryParams = {};

    let headerParams = {
      "If-None-Match": getSteeringPolicyRequest.ifNoneMatch,
      "If-Modified-Since": getSteeringPolicyRequest.ifModifiedSince,
      "opc-request-id": getSteeringPolicyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies/{steeringPolicyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getSteeringPolicyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSteeringPolicyResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicy",
        bodyModel: "model.SteeringPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about the specified steering policy attachment.
   *
   * @param GetSteeringPolicyAttachmentRequest
   * @return GetSteeringPolicyAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async getSteeringPolicyAttachment(
    getSteeringPolicyAttachmentRequest: requests.GetSteeringPolicyAttachmentRequest
  ): Promise<responses.GetSteeringPolicyAttachmentResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getSteeringPolicyAttachment.");
    const pathParams = {
      "{steeringPolicyAttachmentId}": getSteeringPolicyAttachmentRequest.steeringPolicyAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "If-None-Match": getSteeringPolicyAttachmentRequest.ifNoneMatch,
      "If-Modified-Since": getSteeringPolicyAttachmentRequest.ifModifiedSince,
      "opc-request-id": getSteeringPolicyAttachmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicyAttachments/{steeringPolicyAttachmentId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getSteeringPolicyAttachmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetSteeringPolicyAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicyAttachment",
        bodyModel: "model.SteeringPolicyAttachment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about the specified TSIG key.
   *
   * @param GetTsigKeyRequest
   * @return GetTsigKeyResponse
   * @throws OciError when an error occurs
   */
  public async getTsigKey(
    getTsigKeyRequest: requests.GetTsigKeyRequest
  ): Promise<responses.GetTsigKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getTsigKey.");
    const pathParams = {
      "{tsigKeyId}": getTsigKeyRequest.tsigKeyId
    };

    const queryParams = {};

    let headerParams = {
      "If-None-Match": getTsigKeyRequest.ifNoneMatch,
      "If-Modified-Since": getTsigKeyRequest.ifModifiedSince,
      "opc-request-id": getTsigKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys/{tsigKeyId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getTsigKeyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetTsigKeyResponse>{},
        body: await response.json(),
        bodyKey: "tsigKey",
        bodyModel: "model.TsigKey",
        responseHeaders: [
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets information about the specified zone, including its creation date,
   * zone type, and serial.
   *
   * @param GetZoneRequest
   * @return GetZoneResponse
   * @throws OciError when an error occurs
   */
  public async getZone(
    getZoneRequest: requests.GetZoneRequest
  ): Promise<responses.GetZoneResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getZone.");
    const pathParams = {
      "{zoneNameOrId}": getZoneRequest.zoneNameOrId
    };

    const queryParams = {
      "compartmentId": getZoneRequest.compartmentId
    };

    let headerParams = {
      "If-None-Match": getZoneRequest.ifNoneMatch,
      "If-Modified-Since": getZoneRequest.ifModifiedSince,
      "opc-request-id": getZoneRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getZoneRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetZoneResponse>{},
        body: await response.json(),
        bodyKey: "zone",
        bodyModel: "model.Zone",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Gets all records in the specified zone. The results are
   * sorted by `domain` in alphabetical order by default. For more
   * information about records, see [Resource Record (RR) TYPEs](https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4).
   *
   * @param GetZoneRecordsRequest
   * @return GetZoneRecordsResponse
   * @throws OciError when an error occurs
   */
  public async getZoneRecords(
    getZoneRecordsRequest: requests.GetZoneRecordsRequest
  ): Promise<responses.GetZoneRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#getZoneRecords.");
    const pathParams = {
      "{zoneNameOrId}": getZoneRecordsRequest.zoneNameOrId
    };

    const queryParams = {
      "limit": getZoneRecordsRequest.limit,
      "page": getZoneRecordsRequest.page,
      "zoneVersion": getZoneRecordsRequest.zoneVersion,
      "domain": getZoneRecordsRequest.domain,
      "domainContains": getZoneRecordsRequest.domainContains,
      "rtype": getZoneRecordsRequest.rtype,
      "sortBy": getZoneRecordsRequest.sortBy,
      "sortOrder": getZoneRecordsRequest.sortOrder,
      "compartmentId": getZoneRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-None-Match": getZoneRecordsRequest.ifNoneMatch,
      "If-Modified-Since": getZoneRecordsRequest.ifModifiedSince,
      "opc-request-id": getZoneRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      getZoneRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.GetZoneRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.Record objects
   * contained in responses from the getZoneRecords operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllZoneRecords(
    request: requests.GetZoneRecordsRequest
  ): AsyncIterableIterator<models.Record> {
    return genericPaginateRecords(
      request,
      req => this.getZoneRecords(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken),
      res => res.recordCollection.items || []
    );
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the getZoneRecords operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public getAllZoneRecordsResponses(
    request: requests.GetZoneRecordsRequest
  ): AsyncIterableIterator<responses.GetZoneRecordsResponse> {
    return genericPaginateResponses(
      request,
      req => this.getZoneRecords(req),
      res => res.opcNextPage,
      (req, nextPageToken) => (req.page = nextPageToken)
    );
  }

  /**
   * Gets a list of all steering policies in the specified compartment.
   *
   * @param ListSteeringPoliciesRequest
   * @return ListSteeringPoliciesResponse
   * @throws OciError when an error occurs
   */
  public async listSteeringPolicies(
    listSteeringPoliciesRequest: requests.ListSteeringPoliciesRequest
  ): Promise<responses.ListSteeringPoliciesResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#listSteeringPolicies.");
    const pathParams = {};

    const queryParams = {
      "limit": listSteeringPoliciesRequest.limit,
      "page": listSteeringPoliciesRequest.page,
      "compartmentId": listSteeringPoliciesRequest.compartmentId,
      "id": listSteeringPoliciesRequest.id,
      "displayName": listSteeringPoliciesRequest.displayName,
      "displayNameContains": listSteeringPoliciesRequest.displayNameContains,
      "healthCheckMonitorId": listSteeringPoliciesRequest.healthCheckMonitorId,
      "timeCreatedGreaterThanOrEqualTo":
        listSteeringPoliciesRequest.timeCreatedGreaterThanOrEqualTo,
      "timeCreatedLessThan": listSteeringPoliciesRequest.timeCreatedLessThan,
      "template": listSteeringPoliciesRequest.template,
      "lifecycleState": listSteeringPoliciesRequest.lifecycleState,
      "sortBy": listSteeringPoliciesRequest.sortBy,
      "sortOrder": listSteeringPoliciesRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listSteeringPoliciesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSteeringPoliciesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSteeringPoliciesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SteeringPolicySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SteeringPolicySummary objects
   * contained in responses from the listSteeringPolicies operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSteeringPolicies(
    request: requests.ListSteeringPoliciesRequest
  ): AsyncIterableIterator<models.SteeringPolicySummary> {
    return paginateRecords(request, req => this.listSteeringPolicies(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSteeringPolicies operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSteeringPoliciesResponses(
    request: requests.ListSteeringPoliciesRequest
  ): AsyncIterableIterator<responses.ListSteeringPoliciesResponse> {
    return paginateResponses(request, req => this.listSteeringPolicies(req));
  }

  /**
   * Lists the steering policy attachments in the specified compartment.
   *
   * @param ListSteeringPolicyAttachmentsRequest
   * @return ListSteeringPolicyAttachmentsResponse
   * @throws OciError when an error occurs
   */
  public async listSteeringPolicyAttachments(
    listSteeringPolicyAttachmentsRequest: requests.ListSteeringPolicyAttachmentsRequest
  ): Promise<responses.ListSteeringPolicyAttachmentsResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DnsClient#listSteeringPolicyAttachments.");
    const pathParams = {};

    const queryParams = {
      "limit": listSteeringPolicyAttachmentsRequest.limit,
      "page": listSteeringPolicyAttachmentsRequest.page,
      "compartmentId": listSteeringPolicyAttachmentsRequest.compartmentId,
      "id": listSteeringPolicyAttachmentsRequest.id,
      "displayName": listSteeringPolicyAttachmentsRequest.displayName,
      "steeringPolicyId": listSteeringPolicyAttachmentsRequest.steeringPolicyId,
      "zoneId": listSteeringPolicyAttachmentsRequest.zoneId,
      "domain": listSteeringPolicyAttachmentsRequest.domain,
      "domainContains": listSteeringPolicyAttachmentsRequest.domainContains,
      "timeCreatedGreaterThanOrEqualTo":
        listSteeringPolicyAttachmentsRequest.timeCreatedGreaterThanOrEqualTo,
      "timeCreatedLessThan": listSteeringPolicyAttachmentsRequest.timeCreatedLessThan,
      "lifecycleState": listSteeringPolicyAttachmentsRequest.lifecycleState,
      "sortBy": listSteeringPolicyAttachmentsRequest.sortBy,
      "sortOrder": listSteeringPolicyAttachmentsRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listSteeringPolicyAttachmentsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicyAttachments",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listSteeringPolicyAttachmentsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListSteeringPolicyAttachmentsResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "SteeringPolicyAttachmentSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.SteeringPolicyAttachmentSummary objects
   * contained in responses from the listSteeringPolicyAttachments operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSteeringPolicyAttachments(
    request: requests.ListSteeringPolicyAttachmentsRequest
  ): AsyncIterableIterator<models.SteeringPolicyAttachmentSummary> {
    return paginateRecords(request, req => this.listSteeringPolicyAttachments(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listSteeringPolicyAttachments operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllSteeringPolicyAttachmentsResponses(
    request: requests.ListSteeringPolicyAttachmentsRequest
  ): AsyncIterableIterator<responses.ListSteeringPolicyAttachmentsResponse> {
    return paginateResponses(request, req => this.listSteeringPolicyAttachments(req));
  }

  /**
   * Gets a list of all TSIG keys in the specified compartment.
   *
   * @param ListTsigKeysRequest
   * @return ListTsigKeysResponse
   * @throws OciError when an error occurs
   */
  public async listTsigKeys(
    listTsigKeysRequest: requests.ListTsigKeysRequest
  ): Promise<responses.ListTsigKeysResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#listTsigKeys.");
    const pathParams = {};

    const queryParams = {
      "limit": listTsigKeysRequest.limit,
      "page": listTsigKeysRequest.page,
      "compartmentId": listTsigKeysRequest.compartmentId,
      "id": listTsigKeysRequest.id,
      "name": listTsigKeysRequest.name,
      "lifecycleState": listTsigKeysRequest.lifecycleState,
      "sortBy": listTsigKeysRequest.sortBy,
      "sortOrder": listTsigKeysRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listTsigKeysRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listTsigKeysRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListTsigKeysResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "TsigKeySummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.TsigKeySummary objects
   * contained in responses from the listTsigKeys operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTsigKeys(
    request: requests.ListTsigKeysRequest
  ): AsyncIterableIterator<models.TsigKeySummary> {
    return paginateRecords(request, req => this.listTsigKeys(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listTsigKeys operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllTsigKeysResponses(
    request: requests.ListTsigKeysRequest
  ): AsyncIterableIterator<responses.ListTsigKeysResponse> {
    return paginateResponses(request, req => this.listTsigKeys(req));
  }

  /**
   * Gets a list of all zones in the specified compartment. The collection
   * can be filtered by name, time created, and zone type.
   *
   * @param ListZonesRequest
   * @return ListZonesResponse
   * @throws OciError when an error occurs
   */
  public async listZones(
    listZonesRequest: requests.ListZonesRequest
  ): Promise<responses.ListZonesResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#listZones.");
    const pathParams = {};

    const queryParams = {
      "limit": listZonesRequest.limit,
      "page": listZonesRequest.page,
      "compartmentId": listZonesRequest.compartmentId,
      "name": listZonesRequest.name,
      "nameContains": listZonesRequest.nameContains,
      "zoneType": listZonesRequest.zoneType,
      "timeCreatedGreaterThanOrEqualTo": listZonesRequest.timeCreatedGreaterThanOrEqualTo,
      "timeCreatedLessThan": listZonesRequest.timeCreatedLessThan,
      "lifecycleState": listZonesRequest.lifecycleState,
      "sortBy": listZonesRequest.sortBy,
      "sortOrder": listZonesRequest.sortOrder
    };

    let headerParams = {
      "opc-request-id": listZonesRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones",
      method: "GET",
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      listZonesRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.ListZonesResponse>{},
        body: await response.json(),
        bodyKey: "items",
        bodyModel: "ZoneSummary[]",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Creates a new async iterator which will iterate over the models.ZoneSummary objects
   * contained in responses from the listZones operation. This iterator will fetch more data from the
   * server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllZones(
    request: requests.ListZonesRequest
  ): AsyncIterableIterator<models.ZoneSummary> {
    return paginateRecords(request, req => this.listZones(req));
  }

  /**
   * Creates a new async iterator which will iterate over the responses received from the listZones operation. This iterator
   * will fetch more data from the server as needed.
   *
   * @param request a request which can be sent to the service operation
   */
  public listAllZonesResponses(
    request: requests.ListZonesRequest
  ): AsyncIterableIterator<responses.ListZonesResponse> {
    return paginateResponses(request, req => this.listZones(req));
  }

  /**
   * Updates records in the specified zone at a domain. You can update
   * one record or all records for the specified zone depending on the changes
   * provided in the request body. You can also add or remove records using this
   * function.
   *
   * @param PatchDomainRecordsRequest
   * @return PatchDomainRecordsResponse
   * @throws OciError when an error occurs
   */
  public async patchDomainRecords(
    patchDomainRecordsRequest: requests.PatchDomainRecordsRequest
  ): Promise<responses.PatchDomainRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#patchDomainRecords.");
    const pathParams = {
      "{zoneNameOrId}": patchDomainRecordsRequest.zoneNameOrId,
      "{domain}": patchDomainRecordsRequest.domain
    };

    const queryParams = {
      "compartmentId": patchDomainRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-Match": patchDomainRecordsRequest.ifMatch,
      "If-Unmodified-Since": patchDomainRecordsRequest.ifUnmodifiedSince,
      "opc-request-id": patchDomainRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}",
      method: "PATCH",
      bodyContent: common.ObjectSerializer.serialize(
        patchDomainRecordsRequest.patchDomainRecordsDetails,
        "PatchDomainRecordsDetails",
        models.PatchDomainRecordsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      patchDomainRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PatchDomainRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates records in the specified RRSet.
   * @param PatchRRSetRequest
   * @return PatchRRSetResponse
   * @throws OciError when an error occurs
   */
  public async patchRRSet(
    patchRRSetRequest: requests.PatchRRSetRequest
  ): Promise<responses.PatchRRSetResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#patchRRSet.");
    const pathParams = {
      "{zoneNameOrId}": patchRRSetRequest.zoneNameOrId,
      "{domain}": patchRRSetRequest.domain,
      "{rtype}": patchRRSetRequest.rtype
    };

    const queryParams = {
      "compartmentId": patchRRSetRequest.compartmentId
    };

    let headerParams = {
      "If-Match": patchRRSetRequest.ifMatch,
      "If-Unmodified-Since": patchRRSetRequest.ifUnmodifiedSince,
      "opc-request-id": patchRRSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}/{rtype}",
      method: "PATCH",
      bodyContent: common.ObjectSerializer.serialize(
        patchRRSetRequest.patchRRSetDetails,
        "PatchRRSetDetails",
        models.PatchRRSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      patchRRSetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PatchRRSetResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates a collection of records in the specified zone. You can update
   * one record or all records for the specified zone depending on the
   * changes provided in the request body. You can also add or remove records
   * using this function.
   *
   * @param PatchZoneRecordsRequest
   * @return PatchZoneRecordsResponse
   * @throws OciError when an error occurs
   */
  public async patchZoneRecords(
    patchZoneRecordsRequest: requests.PatchZoneRecordsRequest
  ): Promise<responses.PatchZoneRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#patchZoneRecords.");
    const pathParams = {
      "{zoneNameOrId}": patchZoneRecordsRequest.zoneNameOrId
    };

    const queryParams = {
      "compartmentId": patchZoneRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-Match": patchZoneRecordsRequest.ifMatch,
      "If-Unmodified-Since": patchZoneRecordsRequest.ifUnmodifiedSince,
      "opc-request-id": patchZoneRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records",
      method: "PATCH",
      bodyContent: common.ObjectSerializer.serialize(
        patchZoneRecordsRequest.patchZoneRecordsDetails,
        "PatchZoneRecordsDetails",
        models.PatchZoneRecordsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      patchZoneRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.PatchZoneRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Replaces records in the specified zone at a domain with the records
   * specified in the request body. If a specified record does not exist,
   * it will be created. If the record exists, then it will be updated to
   * represent the record in the body of the request. If a record in the zone
   * does not exist in the request body, the record will be removed from the
   * zone.
   *
   * @param UpdateDomainRecordsRequest
   * @return UpdateDomainRecordsResponse
   * @throws OciError when an error occurs
   */
  public async updateDomainRecords(
    updateDomainRecordsRequest: requests.UpdateDomainRecordsRequest
  ): Promise<responses.UpdateDomainRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateDomainRecords.");
    const pathParams = {
      "{zoneNameOrId}": updateDomainRecordsRequest.zoneNameOrId,
      "{domain}": updateDomainRecordsRequest.domain
    };

    const queryParams = {
      "compartmentId": updateDomainRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-Match": updateDomainRecordsRequest.ifMatch,
      "If-Unmodified-Since": updateDomainRecordsRequest.ifUnmodifiedSince,
      "opc-request-id": updateDomainRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateDomainRecordsRequest.updateDomainRecordsDetails,
        "UpdateDomainRecordsDetails",
        models.UpdateDomainRecordsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateDomainRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateDomainRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Replaces records in the specified RRSet.
   * @param UpdateRRSetRequest
   * @return UpdateRRSetResponse
   * @throws OciError when an error occurs
   */
  public async updateRRSet(
    updateRRSetRequest: requests.UpdateRRSetRequest
  ): Promise<responses.UpdateRRSetResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateRRSet.");
    const pathParams = {
      "{zoneNameOrId}": updateRRSetRequest.zoneNameOrId,
      "{domain}": updateRRSetRequest.domain,
      "{rtype}": updateRRSetRequest.rtype
    };

    const queryParams = {
      "compartmentId": updateRRSetRequest.compartmentId
    };

    let headerParams = {
      "If-Match": updateRRSetRequest.ifMatch,
      "If-Unmodified-Since": updateRRSetRequest.ifUnmodifiedSince,
      "opc-request-id": updateRRSetRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records/{domain}/{rtype}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateRRSetRequest.updateRRSetDetails,
        "UpdateRRSetDetails",
        models.UpdateRRSetDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateRRSetRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateRRSetResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the configuration of the specified steering policy.
   *
   * @param UpdateSteeringPolicyRequest
   * @return UpdateSteeringPolicyResponse
   * @throws OciError when an error occurs
   */
  public async updateSteeringPolicy(
    updateSteeringPolicyRequest: requests.UpdateSteeringPolicyRequest
  ): Promise<responses.UpdateSteeringPolicyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateSteeringPolicy.");
    const pathParams = {
      "{steeringPolicyId}": updateSteeringPolicyRequest.steeringPolicyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": updateSteeringPolicyRequest.ifMatch,
      "If-Unmodified-Since": updateSteeringPolicyRequest.ifUnmodifiedSince,
      "opc-request-id": updateSteeringPolicyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicies/{steeringPolicyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSteeringPolicyRequest.updateSteeringPolicyDetails,
        "UpdateSteeringPolicyDetails",
        models.UpdateSteeringPolicyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateSteeringPolicyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSteeringPolicyResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicy",
        bodyModel: "model.SteeringPolicy",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the specified steering policy attachment with your new information.
   *
   * @param UpdateSteeringPolicyAttachmentRequest
   * @return UpdateSteeringPolicyAttachmentResponse
   * @throws OciError when an error occurs
   */
  public async updateSteeringPolicyAttachment(
    updateSteeringPolicyAttachmentRequest: requests.UpdateSteeringPolicyAttachmentRequest
  ): Promise<responses.UpdateSteeringPolicyAttachmentResponse> {
    if (this.logger)
      this.logger.debug("Calling operation DnsClient#updateSteeringPolicyAttachment.");
    const pathParams = {
      "{steeringPolicyAttachmentId}":
        updateSteeringPolicyAttachmentRequest.steeringPolicyAttachmentId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": updateSteeringPolicyAttachmentRequest.ifMatch,
      "If-Unmodified-Since": updateSteeringPolicyAttachmentRequest.ifUnmodifiedSince,
      "opc-request-id": updateSteeringPolicyAttachmentRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/steeringPolicyAttachments/{steeringPolicyAttachmentId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateSteeringPolicyAttachmentRequest.updateSteeringPolicyAttachmentDetails,
        "UpdateSteeringPolicyAttachmentDetails",
        models.UpdateSteeringPolicyAttachmentDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateSteeringPolicyAttachmentRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateSteeringPolicyAttachmentResponse>{},
        body: await response.json(),
        bodyKey: "steeringPolicyAttachment",
        bodyModel: "model.SteeringPolicyAttachment",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the specified TSIG key.
   *
   * @param UpdateTsigKeyRequest
   * @return UpdateTsigKeyResponse
   * @throws OciError when an error occurs
   */
  public async updateTsigKey(
    updateTsigKeyRequest: requests.UpdateTsigKeyRequest
  ): Promise<responses.UpdateTsigKeyResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateTsigKey.");
    const pathParams = {
      "{tsigKeyId}": updateTsigKeyRequest.tsigKeyId
    };

    const queryParams = {};

    let headerParams = {
      "If-Match": updateTsigKeyRequest.ifMatch,
      "If-Unmodified-Since": updateTsigKeyRequest.ifUnmodifiedSince,
      "opc-request-id": updateTsigKeyRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/tsigKeys/{tsigKeyId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateTsigKeyRequest.updateTsigKeyDetails,
        "UpdateTsigKeyDetails",
        models.UpdateTsigKeyDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateTsigKeyRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateTsigKeyResponse>{},
        body: await response.json(),
        bodyKey: "tsigKey",
        bodyModel: "model.TsigKey",
        responseHeaders: [
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Updates the specified secondary zone with your new external master
   * server information. For more information about secondary zone, see
   * [Manage DNS Service Zone](https://docs.cloud.oracle.com/iaas/Content/DNS/Tasks/managingdnszones.htm).
   *
   * @param UpdateZoneRequest
   * @return UpdateZoneResponse
   * @throws OciError when an error occurs
   */
  public async updateZone(
    updateZoneRequest: requests.UpdateZoneRequest
  ): Promise<responses.UpdateZoneResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateZone.");
    const pathParams = {
      "{zoneNameOrId}": updateZoneRequest.zoneNameOrId
    };

    const queryParams = {
      "compartmentId": updateZoneRequest.compartmentId
    };

    let headerParams = {
      "If-Match": updateZoneRequest.ifMatch,
      "If-Unmodified-Since": updateZoneRequest.ifUnmodifiedSince,
      "opc-request-id": updateZoneRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateZoneRequest.updateZoneDetails,
        "UpdateZoneDetails",
        models.UpdateZoneDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateZoneRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateZoneResponse>{},
        body: await response.json(),
        bodyKey: "zone",
        bodyModel: "model.Zone",
        responseHeaders: [
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }

  /**
   * Replaces records in the specified zone with the records specified in the
   * request body. If a specified record does not exist, it will be created.
   * If the record exists, then it will be updated to represent the record in
   * the body of the request. If a record in the zone does not exist in the
   * request body, the record will be removed from the zone.
   *
   * @param UpdateZoneRecordsRequest
   * @return UpdateZoneRecordsResponse
   * @throws OciError when an error occurs
   */
  public async updateZoneRecords(
    updateZoneRecordsRequest: requests.UpdateZoneRecordsRequest
  ): Promise<responses.UpdateZoneRecordsResponse> {
    if (this.logger) this.logger.debug("Calling operation DnsClient#updateZoneRecords.");
    const pathParams = {
      "{zoneNameOrId}": updateZoneRecordsRequest.zoneNameOrId
    };

    const queryParams = {
      "compartmentId": updateZoneRecordsRequest.compartmentId
    };

    let headerParams = {
      "If-Match": updateZoneRecordsRequest.ifMatch,
      "If-Unmodified-Since": updateZoneRecordsRequest.ifUnmodifiedSince,
      "opc-request-id": updateZoneRecordsRequest.opcRequestId
    };

    const request = await composeRequest({
      baseEndpoint: this._endpoint,
      defaultHeaders: this._defaultHeaders,
      path: "/zones/{zoneNameOrId}/records",
      method: "PUT",
      bodyContent: common.ObjectSerializer.serialize(
        updateZoneRecordsRequest.updateZoneRecordsDetails,
        "UpdateZoneRecordsDetails",
        models.UpdateZoneRecordsDetails.getJsonObj
      ),
      pathParams: pathParams,
      headerParams: headerParams,
      queryParams: queryParams
    });
    const retrier = GenericRetrier.createPreferredRetrier(
      this._clientConfiguration ? this._clientConfiguration.retryConfiguration : {},
      updateZoneRecordsRequest.retryConfiguration
    );
    if (this.logger) retrier.logger = this.logger;
    try {
      const response = await retrier.makeServiceCall(this._httpClient, request);
      const sdkResponse = composeResponse({
        responseObject: <responses.UpdateZoneRecordsResponse>{},
        body: await response.json(),
        bodyKey: "recordCollection",
        bodyModel: "model.RecordCollection",
        responseHeaders: [
          {
            value: response.headers.get("opc-next-page"),
            key: "opcNextPage",
            dataType: "string"
          },
          {
            value: response.headers.get("opc-total-items"),
            key: "opcTotalItems",
            dataType: "number"
          },
          {
            value: response.headers.get("opc-request-id"),
            key: "opcRequestId",
            dataType: "string"
          },
          {
            value: response.headers.get("ETag"),
            key: "eTag",
            dataType: "string"
          }
        ]
      });

      return sdkResponse;
    } catch (err) {
      throw err;
    }
  }
}
